# C++ 三大特性

## 封装

> 把数据和操作这些数据的方法（函数）集中起来，集中起来有两大好处：一是便于管理。这很好理解，比起散落在代码各处的变量和方法，集中的数据和方法很好管理；二是权限。对于封装起来的数据和方法，可以选择对外暴露，也可以选择对外不可见，还可以选择对外部分可见。

实现方法：

- 类
- 结构体

> C++ 类和结构体的区别?
>
> **成员的默认访问权限**：
>
> - 类中的成员默认是私有的（private），即在类的外部无法直接访问类的私有成员。
> - 结构体中的成员默认是公共的（public），即在结构体的外部可以直接访问结构体的成员。
>
> **使用习惯**：
>
> - 通常来说，类更适合用来表示具有复杂行为和功能的数据类型，因为类允许封装数据和行为，并通过成员函数提供接口。
> - 结构体通常用于简单的数据结构，如坐标点、矩形等，其中仅包含数据而没有复杂的行为。

## 继承

> 允许一个类（子类或派生类）从另一个类（父类或基类）继承属性和行为。子类可以继承父类的成员变量和成员函数，并且可以通过添加新成员或覆盖继承的成员来扩展或修改功能。



> 在继承场景下，基类析构函数定义为虚函数的原因? 
> 基类析构不为虚函数为什么不会执行派生类析构函数？
> 如果不定义虚析构，那么派生类虚函数列表中指向的是父类的析构函数吗?
>
> 1. 在继承场景下，将基类的析构函数定义为虚函数的主要原因是为了正确处理多态析构。当你使用基类的指针或引用指向派生类的对象，并在销毁时调用析构函数时，如果基类的析构函数不是虚函数，就会发生对象切片（object slicing）问题，导致派生类特有的成员和资源无法正确释放，可能造成内存泄漏或未定义行为。
> 2. 编译器在没有虚析构函数的情况下，无法确定应该调用哪个类的析构函数。因此，编译器会根据指针或引用的静态类型来调用适当的析构函数，从而忽略了派生类的析构函数。这就是为什么要将基类的析构函数定义为虚函数，以允许在运行时动态绑定正确的析构函数。
> 3. 如果基类的析构函数不定义为虚析构，那么在基类指针指向派生类对象时，是通过静态类型来调用的，虚函数表中并没有析构函数。

>  将子类的对象直接赋值给父类的对象会发生什么? 丢失掉的那部分在C++中被称为什么(专业术语)?
>
> 将子类的对象直接赋值给父类的对象会发生对象切片（Object Slicing）。对象切片是指将派生类对象赋值给基类对象时，会丢失派生类对象中的那部分数据，只保留基类部分的数据，从而导致派生类特有的信息丢失。

> 子类继承多个父类，虚函数列表是怎么样的？多继承，父类有重名函数会怎么样?
>
> 1. 多重继承会有多个虚函数表，几重继承，就会有几个虚函数表。这些表按照派生的顺序依次排列，如果子类改写了父类的虚函数，那么就会用子类自己的虚函数***覆盖***虚函数表的相应的位置，如果子类有新的虚函数，那么就添加到第一个虚函数表的末尾。
>
> 2. C++中的默认行为：默认情况下，C++ 使用“最后的派生类覆盖先前的派生类”规则，即派生类中的同名函数会覆盖所有基类的同名函数。
>
> 	为了解决菱形继承问题，C++引入了虚继承（virtual inheritance）的概念。虚继承允许你在派生类中指定从多个基类中继承同一个共同基类时，只保留一个实例。这可以避免派生类中存在多个同名的基类子对象，从而解决了菱形继承的问题。
>
> 

## 多态

> 允许使用同一接口来处理不同的数据类型或对象，从而实现更加灵活和通用的代码。多态性通过两种方式实现：编译时多态性（静态多态性）和运行时多态性（动态多态性）。静态多态性是通过函数重载和运算符重载来实现的，允许在编译时选择正确的函数或操作符。动态多态性是通过基类的指针或引用调用虚函数来实现的，允许在运行时确定调用的具体函数，使用虚函数实现的。



> 虚函数列表具体记录了哪些内容? 虚函数列表在什么时候生成? 虚函数指针在什么时候生成?
>
> 1. 虚函数列表通常是一个数组，调用虚函数就是通过对象内存的头部通常包含一个指向虚函数列表的指针，虚函数列表中每一个元素，虚函数地址通常是按在类内的定义顺序来确定的，调用的时候通过下标找到对应的虚函数地址，再转向调用。
> 2. 虚函数列表和虚函数指针都是在编译期生成的，而不是在运行时生成的。它们是编译器为了实现运行时多态性（动态绑定）所创建的。

## 面向对象常用的设计模式

**单例模式（Singleton Pattern）**： 保证一个类只有一个实例，并提供一个全局访问点来访问这个实例。

**工厂模式（Factory Pattern）**： 用于创建对象的接口，将对象的创建从客户代码中解耦，以便更灵活地创建不同类型的对象。

**模板方法模式（Template Method Pattern）**： 定义一个算法的骨架，将一些步骤延迟到子类中，从而使子类可以重新定义算法的某些特定步骤。

##  ***覆盖 隐藏 重载*** 的区别：

***覆盖*** 是C++虚函数的实现原理，基类的虚函数被子类重写，要求函数参数列表相同；

***隐藏*** 是C++的名字解析过程，分两种情况，基类函数有virtual，参数列表不同，或基类函数没有virtual，无论参数列表是否相同。此时基类指针指向基类实例则调用基类函数，指向子类则调用子类函数。

***重载*** 是在同一命名空间中根据参数对同名函数的区别。

