```markmap
# 计算机网络

## ISO七层网络模型

### 应用层

#### HTTP(80)

#### HTTPS(443)

#### FTP(21)

#### DNS(53)

#### DHCP(68)

#### Telnet(23)

#### SMTP(25)

#### SSH(22)

### 表示层

#### 数据加解密

#### 数据解压缩

#### 图片/视频编解码

##### 视频编解码技术

###### H264, H265等

##### 第三方视频编解码库

###### ffmpeg

##### 视频数据冗余类型

###### 时间冗余

####### 视频相邻的两帧之间内容相似，存在运动关系

###### 空间冗余

####### 视频的某一帧内部的相邻像素存在相似性

###### 编码冗余

####### 视频中不同数据出现的概率不同

###### 视觉冗余

####### 观众的视觉系统对视频中不同的部分敏感度不同

### 会话层

#### session会话管理

#### 服务器验证用户登录

#### 断点续传

### 传输层

#### TCP

#### UDP

### 网络层

#### IP

#### ARP

##### 根据IP地址获取物理地址

#### RARP

#### ICMP

##### 互联网控制报文协议(Internet Control Message Protocol)

##### 主要功能

###### 确认 IP 包是否成功送达目标地址

###### 报告发送过程中 IP 包被废弃的原因和改善网络设置

##### Ping的执行过程

###### 构建一个 ICMP的查询报文(Echo Request ）【类型为8】

###### 以广播的方式发生ARP请求包

####### 获得目标主机的MAC地址

### 数据链路层

### 物理层

## TCP/IP四层网络模型

### 什么是TCP/IP网络模型，为什么要有TCP/IP网络模型？

#### 同一台设备内的进程间通信，有管道，消息队列，共享内存，信号等方式，对于不同设备上的进程间通信，需要通过网络通信，而设备是多种多样的，需要一套通用的网络协议(规则)来兼容各式各样的设备

### 应用层

#### 工作重心

##### 不关心数据是怎么传输的，专注为用户提高应用功能

##### 工作在操作系统的用户态，传输层及以下工作在内核态

#### HTTP

##### HTTP 基本概念

###### HTTP是什么?

####### 超文本传输协议

######## 传输超文本(文字、图片、音频、视频)

###### HTTP常见的状态码

####### 1xx

######## 提示信息, 表示当前处于协议处理的中间状态，还需要后续操作

####### 2xx

######## 成功，报文已被成功接受并被正确处理

####### 3xx

######## 重定向，资源位置发生变化，需要客户端重新发起请求

####### 4xx

######## 客户端错误，请求报文有误，服务器无法处理

####### 5xx

######## 服务器错误，服务器在处理请求时内部发生错误

###### HTTP常见的字段

####### 请求字段

######## Host字段

######### 指定服务器的域名

######## Connection 字段

######### 设为keep-alive表示客户端要求HTTP长连接

######### 长连接的特点：

########## 两端只有没有人主动断开连接，则保持TCP连接

######### HTTP/1.1 默认长连接, 为了兼容老版本该字段需要置为Keep-Alive

####### 回复字段

######## Content-Length 字段

######### 回应的数据长度

######### HTTP通过\r\n\r\n作为HTTP Header边界,通过这个字段作为HTTP Body边界

######### 解决沾包问题

######## Content-Type 字段

######### 回应的数据格式

######## Content-Encoding 字段

######### response数据的压缩格式

##### Get 与 Post

###### GET和POST的区别

####### GET

######## 语义：从服务器获取指定的资源

####### POST

######## 语义：根据请求负荷（报文body）对指定的资源做出处理

###### 安全和幂等( RFC 规范定义的语义来分析)

####### 概念

######## 安全

######### 是指请求方法不会「破坏」服务器上的资源

######## 幂等

######### 多次执行相同的操作，结果都是「相同」的

####### GET请求是安全和幂等的

######## 只读操作

######## 因此，可以对GET请求的资源做缓存, 这个缓存可以做到浏览器上，也可以做到nginx代理服务器上

####### POST请求不是安全和幂等的

######## 「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的

######## 多次提交数据就会创建多个资源，所以不是幂等的

###### POST用body传输数据，GET用url传输数据

####### 但是这并不说POST比GET要安全(信息不会在地址栏被看见，泄漏)，因为整个HTTP都是明文传输的、

##### HTTP 缓存技术

###### 实现方式

####### 对于一些具有重复性质的HTTP请求，可以把请求-响应缓存到本地；下次直接读取本地数据，不必通过网络向服务器发请求和获取响应了

####### 强制缓存

####### 协商缓存

###### 什么是强制缓存

####### 请求发起方判断缓存有没有过期

######## 利用HTTP头部的`Cache-Control`或`Expires`字段

######## 实现流程

######### 1. 浏览器第一次请求资源时，服务器在返回资源时在Response Header的Cache-Control字段设置过期时间

######### 2. 浏览器再次请求该资源时，先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器

######### 3. 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control

###### 什么是协商缓存

####### 服务器来告知是否使用本地缓存

######## 服务器返回的响应状态码为304

###### 工作流程

###### 

##### HTTP 特性

###### HTTP/1.1的优缺点

####### 优点

######## 简单、灵活和易于扩展、应用广泛和跨平台

####### 优缺一体点

######## 无状态

######### 优点

########## 服务器不会记忆HTTP的状态，不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务

######### 坏处

########## 有关联关系的请求服务器并不知道

########### 解决办法：Cookie

############ 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态

######## 明文传输

######### 优点

########## 方便可读

######### 缺点

########## 没有隐私，不安全

####### 缺点

######## 不安全

######### 通信使用明文，内容可能会被窃听

######### 不验证通信方的身份，因此有可能遭遇伪装

######### 无法证明报文的完整性，所以有可能已遭篡改

###### HTTP/1.1 的性能

####### 长连接

######## 因为HTTP是基于TCP的，意味着每次通信都需要三次握手建立连接，长连接减少了无谓的 TCP 连接建立和断开

####### 管道网络传输

#######  队头阻塞

####### 性能瓶颈

######## 请求/响应头部未经压缩就发出首部信息越多延迟越大。只能压缩 Body 的部分

######## 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞

######## 没有请求优先级控制

######## 请求只能从客户端开始，服务器只能被动响应

##### HTTPS 与 HTTP

###### 区别

####### HTTPS在HTTP和TCP之间加入了SSL/TLS安全协议，使得报文能够加密传输 

####### HTTPS在TCP三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输

###### HTTPS解决了HTTP的哪些问题

####### 解决的问题

######## 窃听风险

######## 篡改风险

######## 冒充风险

####### 解决方法

######## 信息加密

######### 混合加密

######## 校验机制

######### 摘要算法(hash)

######## 身份证书

######### 数字证书

###### HTTPS是如何建立连接的

####### SSL/TLS 协议基本流程

######## 客户端向服务器索要并验证服务器的公钥。

######## 双方协商生产「会话秘钥」。

######## 双方采用「会话秘钥」进行加密通信。

##### HTTP/1.1、HTTP/2、HTTP/3 演变

###### HTTP/1.1 比 HTTP/1.0 提高了哪些性能

####### 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销

####### 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

###### HTTP/2 做了哪些优化

####### 头部压缩

####### 二进制格式

####### 并发传输

####### 服务器主动推送资源

###### HTTP/3 做了哪些优化

### 传输层

#### 为应用层提供网络支持的

##### 端口

###### 向上给应用层传输数据时，需要一个标识来区分数据是哪个进程的

###### 知名端口

####### HTTP(80)

####### HTTPS(443)

####### FTP(21)

####### DNS(53)

####### DHCP(68)

####### Telnet(23)

####### SMTP(25)

####### SSH(22)

#### TCP transport control protocol 传输控制协议

##### TCP基本认识

###### TCP首部格式

####### TCP头部格式

######## 序列号

######### 在建立连接时由计算机生成的随机数作为其初始值

######### 通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小

######### 作用

########## 用来解决网络包乱序问题

######## 确认应答号

######### 指下一次「期望」收到的数据的序列号

######### 发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收

######### 作用

########## 用来解决丢包的问题

######## 控制位

######### ACK

########## 「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1

######### RST

########## 该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接

######### SYN

########## 该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定

######### FIN

########## 该位为 1 时，表示今后不会再有数据发送，希望断开连接

###### 为什么需要TCP？TCP工作在哪一层

####### IP层是不可靠的，IP不保证数据报的可靠交付（按序，完整）

####### TCP工作在传输层，保证接收端接收到的网络包是无损坏的，无间隔，非冗余，按序的

###### 什么是TCP？

####### TCP 是面向连接的、可靠的、基于字节流的传输层通信协议

######## 面向连接

######### 「一对一」连接

######## 可靠的

######### 无论底层的实际物理链路如何，TCP保证报文一定能达到接收端

######## 字节流

######### 对比UDP面向数据报

######### 消息可能会被操作系统分组成多个的 TCP 报文

######### 不能认为一个用户消息对应一个 TCP 报文

######### 当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题

########## 如果接收方不知道消息的边界在哪里，无法读出有效的信息

########### 交给应用程序来解决

########### 如何解决粘包？

############ 通过边界来划分出有效的用户消息

############# 固定长度的消息；

############# 特殊字符作为边界；

############# 自定义消息结构

###### 什么是TCP连接？

####### 用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接

####### 要建立一个TCP连接，客户端和服务器要达成三个方面的共识

######## Socket：由 IP 地址和端口号组成

######## 序列号：用来解决乱序问题等

######## 窗口大小：用来做流量控制

###### 如何唯一确定一个TCP连接

####### CP 四元组可以唯一的确定一个连接

######## 源地址

######## 源端口

######## 目的地址

######## 目的端口

###### 有一个IP的服务器监听了一个端口，它的TCP最大连接数

####### 理论计算公式

######## 最大TCP连接数 = 客户端的IP数 * 客户端的端口数

######### 对IPv4，客户端的IP数最多为2^32次方，端口数最多为2^16次方

######### 约等于2^48次方

####### 服务端最大并发 TCP 连接数远不能达到理论上限

######## 文件描述符限制

######### 每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。

########## 系统级：当前系统可打开的最大数量

########## 用户级：指定用户可打开的最大数量

########## 进程级：单个进程可打开的最大数量

######### 内存限制，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM

###### UDP和TCP有什么区别，分别的应用场景

####### 区别

######## 1. 连接

######### TCP 是面向连接的传输层协议，传输数据前先要建立连接

######### UDP 是不需要连接，即刻传输数据

######## 2. 服务对象

######### TCP 是一对一的两点服务，即一条连接只有两个端点

######### UDP 支持一对一、一对多、多对多的交互通信

######## 3. 可靠性

######### TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达

######### UDP 是尽最大努力交付，不保证可靠交付数据。

######## 4. 拥塞控制、流量控制

######### TCP 有拥塞控制和流量控制机制，保证数据传输的安全性

######### UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率

######## 5. 首部开销

######### TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的

######### UDP 首部只有 8 个字节，并且是固定不变的，开销较小

######## 6. 传输方式

######### TCP 是流式传输，没有边界，但保证顺序和可靠。

######### UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序

######## 7. 分片不同

######### TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。

######### UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

####### 应用场景

######## TCP

######### FTP 文件传输

######### HTTP / HTTPS

######## UDP

######### 包总量较少的通信，如 DNS 、SNMP 等

######### 视频、音频等多媒体通信

######### 广播通信

###### 为什么UDP头部没有首部长度字段，而TCP首部有

####### TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度

###### 为什么UDP首部有包长度字段，而TCP首部没有

###### TCP和UDP可以使用同一个端口吗

####### 首先， 端口号的作用

######## 区分同一个主机上不同应用程序的数据包 

####### 其次，TCP和UDP在内核中是两个相互独立的软件模块

####### 主机在收到数据包后，在IP包头的协议号看到是TCP或者是UDP的，直接将数据送给相应的模块，传输层根据端口号传给相应的应用程序

####### 因此， TCP/UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。

####### 多个 TCP 服务进程可以绑定同一个端口吗？

######## 如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。

######### 重启 TCP 服务进程时，为什么会有“Address in use”的报错信息

######## 如果其中一个进程绑定的IP地址是0.0.0.0也会报错，因为0.0.0.0代表主机上的所有IP地址

######## 也可以

######### 对 socket 设置 SO_REUSEPORT 属性（内核 3.9 版本提供的新特性）

##### TCP连接建立

###### 三次握手

####### TCP三次握手过程和状态变迁

######## 1. 一开始，客户端和服务端都处于CLOSE状态，服务端主动监听某个端口，处于LISTEN状态

######## 第一次握手: 客户端向服务器发送SYN报文

######### 客户端随机初始化序号client_isn

########## 将此序号置于 TCP 首部的「序号」字段中

######### SYN字段置为1

######### 之后客户端处于SYN_SENT状态

######## 第二次握手： 服务器向客户端发送SYN+ACK报文

######### 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn）

######### 将server_isn填入TCP首部的序号字段

######### 确认应答字段填client_isn + 1

######### SYN, ACK字段置为1

######### 之后服务端处于 SYN-RCVD 状态

######## 第三次握手：客户端向服务器发送ACK应答报文

######### 确认应答字段填server_isn + 1

######### ACK字段置为1

######### 这次报文可以携带应用层数据

######### 之后客户端处于 ESTABLISHED 状态

######## 服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态

####### 如何在Linux系统中查看TCP状态

####### 为什么是三次握手？不是两次，四次

######## 三次握手建立TCP连接

######### 什么是TCP连接

########## 通信双方协商好socket， 序列号，窗口大小

######## 三次握手才可以阻止重复历史连接的初始化

######### 什么是历史连接初始化了连接

########## 假设场景

########### 客户端发送了SYN（seq = 90）请求报文后，宕机重启了，并且这个报文也被网络阻塞了，
当客户端重新发送SYN（seq = 100）报文时，服务器会先收到旧的SYN请求，此时服务器返回一个ACK(ack = 91);
而客户端对比上下文，发现自己期望收到的ack是101而不是91，此时客户端发送一个RST终止连接；
后续新的SYN报文到达后才开始建立连接

########### 如果服务端在收到RST之前收到了新的SYN请求报文，就会回 Challenge Ack报文给客户端，这个 ack 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ack 确认号

######### 两次握手连接，就无法阻止历史连接

########## 因为在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费

########## 如果在两次握手情况下，服务端收到了历史连接就直接进入ESTABLISHED状态，但是客户端还没有进入ESTABLISHED，等客户端收到服务端发来的ACK+SYN后，发现不是对的ack，发送RST报文来终止连接

######## 三次握手才可以同步双方的初始序列号

######### 序列号的作用

########## 是实现可靠传输的一个关键因素

######### 四次握手虽然说也能保证通信双方的序列号能可靠同步，但第二次握手的SYN和ACK可以优化成一步

######### 两次握手只能保证客户端的序列号被对方成功接受

######## 三次握手才可以避免资源浪费

######### 如果只有两次握手，当客户端发的SYN连接建立报文在网络中被拥塞了，收不到ACK应答报文只能重新发送SYN报文。
服务端在收到一个SYN报文后，因为只有两次握手，所以只能先进入ESTABLISHED状态
这样服务器就有可能收到重发的多个SYN报文，建立多个冗余无效的TCP连接，造成不必要的资源浪费

###### 初始序列号

####### 为什么每次建立TCP连接时，初始化的序列号都要求不一样

######## 为了防止历史报文被下一个相同四元组的连接接收

######## 初始化序列号不一样很大程度能避免历史报文被服务端错误接受，但是不能完全避免

######### 序列号有回绕问题

####### 初始序列号ISN是如何随机产生的？

######## 起始 ISN 是基于时钟的

###### 为什么IP层会分片，TCP还要有MSS？

####### MTU

######## 一个网络包的最大长度

######### IP首部+TCP首部+TCP报文数据

######## IP分片丢失后，将会重传整个IP数据报，因为IP层没有超时重传机制

######### 为什么会重传整个IP数据报

########## 接收方的IP层无法接受一个完整的数据报就不会向上层转发，传输层TCP没有收到数据就不会发送ACK回应报文，传输方超时没有收到ACK响应就会重发数据

########## 因此，IP层进行分片是非常没有效率的

####### MSS

######## 一个网络包所能容纳的 TCP 数据的最大长度

######## TCP在建立连接的时候，通信的双方就要协商MSS的大小

######### 当TCP发现要发的数据大于MSS后，就会进行分块，因此，数据到达IP层后就不会超过MTU的大小，IP层也就不会再进行分片

######### 当一个MSS分块丢失后，TCP重发也是以MSS为单位，不会整个数据报重发

###### 握手报文丢失

####### 第一次握手丢失后，会发生什么？

######## 客户端在发出建立连接的SYN请求报文后，没有收到服务器的ACK+SYN应答，就会在系统设定的超时时间后触发超时重传机制，重发的SYN报文的序列号跟上一次一致。

######## 当重传次数到达系统设定的最大重传次数后，再等待上一次超时时间的2倍这么长一个时间后，就会放弃连接

####### 第二次握手丢失后，会发生什么？

######## 第二次握手的目的

######### ACK

########## 对客户端发起的建立连接请求应答确认

########### 客户端会发生第一次握手丢失一样的结果

######### SYN

########## 服务器发起建立连接的报文

########### 服务器收不到客户端对SYN的ACK应答，也会触发超时重传机制

####### 第三次握手丢失后，会发生什么？

######## 此时，客户端已经进入ESTABLISHED状态

######## 服务器收不到客户端的对SYN的ACK应答报文，触发超时重传机制

###### 什么是SYN攻击？如何避免SYN攻击

####### 因为TCP建立连接需要三次握手，如果攻击者短时间内伪造大量假IP地址的SYN请求，会使服务器处于SYN_RCVD状态，但服务器发出的ACK-SYN报文得不到未知IP的ACK应答，久而久之会占满服务器的半连接队列，使服务器无法处理正常的连接请求

####### 三次握手的时候，系统会维护两个队列

######## 半连接队列

######### SYN队列

######## 全连接队列

######### accept队列

######## 这两个队列的工作流程

######### 当服务器收到客户端的SYN报文后，会创建一个半连接的对象，加入到SYN队列中，并且向客户端发送SYN-ACK应答

######### 客户端向服务器发送ACK应答被服务器接收到后，从SYN队列中取出一个半连接对象，创建一个全连接队列放入到Accept队列中

######### 应用程序调用accept()接口时，从内核的accept队列中取出一个全连接对象

######## 这两个队列都有最大连接数，超出连接数的请求都会被抛掉

####### 避免SYN攻击的方法

######## 调大 netdev_max_backlog；

######### 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包

######## 增大 TCP 半连接队列；

######### 增大 net.ipv4.tcp_max_syn_backlog

######### 增大 listen() 函数中的 backlog

######### 增大 net.core.somaxconn

######## 开启 tcp_syncookies；

######## 减少 SYN+ACK 重传次数

######### 加快处于 SYN_REVC 状态的 TCP 连接断开

##### TCP连接断开

###### 四次挥手

####### TCP四次挥手过程和状态变迁

######## 1. 一开始，客户端和服务器都处于ESTABLISHED状态

######## 第一次挥手：客户端打开关闭连接，向服务器发送FIN报文

######### FIN字段置为1

######### 此后，客户端进入FIN_WAIT_1 状态

######## 第二次挥手：服务器收到FIN报文后，向客户端发送ACK应答报文

######### 此后，服务器进入CLOSED_WAIT状态

######### 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态

######## 第三次挥手：等待服务端处理完数据后，也向客户端发送 FIN 报文

######### 之后服务端进入 LAST_ACK 状态

######## 第四次挥手: 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文

######### 之后客户端进入 TIME_WAIT 状态

######### 服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭

######### 客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭

######## 主动关闭方，才有TIME_WAIT状态

####### 为什么挥手需要四次

######## 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据

######## 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送

######## 服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接

######## 综上，服务器在收到客户端的FIN报文后，一般都还需要继续处理数据，不能向连接建立那样ACK和SYN一起发送。通常ACK和FIN需要分开发送

###### 挥手报文丢失

####### 第一次挥手丢失了，会发生什么？

######## 客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，当重发的次数达到系统规定的上限时，客户端直接进入CLOSED状态

####### 第二次挥手丢失了，会发生什么？

######## 第二次挥手是一个ACK报文，不会进行重传，丢失了就相当于客户端迟迟收不到服务器的ACK，跟第一次挥手丢失的结果一样，但此时服务器是处于CLOSED_WAIT状态

####### 第三次挥手丢失了，会发生什么？

######## 被动关闭方收到主动关闭方的FIN报文，操作系统会自动回复ACK报文，此时被动连接方处于CLOSED_WAIT状态，等待被动关闭方的应用进程主动调用close()函数来发送FIN报文

######## 当服务器处理完数据向客户端发送FIN报文后丢失，客户端就无法发送ACK应答，服务器收不到ACK应答就会触发超时重传机制，超过系统设定的最大重传次数，服务器就会进入CLOSED状态结束连接

####### 第四次挥手丢失了，会发生什么？

######## 客户端在收到第三次挥手后，进入TIME_WAIT状态，持续2MSL后自动断开连接

######### 途中再次收到第三次挥手（FIN 报文）后，就会重置定时器

######## 服务器收不到ACK应答就会触发超时重传机制，超过系统设定的最大重传次数，服务器就会进入CLOSED状态结束连接

###### TIME_WAIT

####### 为什么TIME_WAIT等待的是2MSL

######## MSL ： Maximum Segment Lifetime(报文最大生存时间)

######### 它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃

######## 被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL

######## 2MSL : 至少允许报文丢失一次

######### 若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对

######## 为什么不是4MSL，8MSL？

######### 发生两次及以上连续丢包的概率不高，忽略它比处理它更具性价比

####### 为什么需要TIME_WAIT状态

######## 防止历史连接中的数据，被后面相同四元组的连接错误的接收

######### 足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的

######## 保证「被动关闭连接」的一方，能被正确的关闭

######### 足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的

######### 如果没有TIME_WAIT状态，客户端在发完最后一次挥手ACK后直接进入CLOSED状态，如果服务器没有收到ACK一定会重传FIN报文，此时CLOSED状态的客户端就会返回RST报文，服务端收到这个 RST 并将其解释为一个错误

####### TIME_WAIT过多会出现什么危害

######## 占用系统资源

######### 服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多

########## 并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接

########## TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源

######## 占用端口资源

######### 客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多

########## 无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了

########## 被使用的端口还是可以继续对另外一个服务端发起连接的

####### TODO:如何优化TIME_WAIT

####### 服务器出现大量TIME_WAIT状态的原因

######## 第一个场景：HTTP 没有使用长连接

######## 第二个场景：HTTP 长连接超时

######## 第三个场景：HTTP 长连接的请求数量达到上限

####### 服务器出现大量 CLOSE_WAIT 状态的原因

######## 服务端的程序没有调用 close 函数关闭连接

######### TODO 排查代码

###### 异常断开处理

####### 如果已经建立连接了，客户端突然出现故障了怎么办

######## 保活机制

######### 如果服务器不主动向客户端发送数据，那服务器将无法感知客户端的状态，将处于ESTABLISHED状态

######### 定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序

####### 如果已经建立连接了，客户端的进程突然崩溃了怎么办

##### 特性

###### 重传机制

####### 超时重传

######## 在发送数据时，启动一个定时器，当超过定时器设定时间后没有收到ack回复，就会重发该数据

######## 发生超时重传的场景

######### 发送出去的数据包丢失

######### 对方返回的ack回应丢失

######## RTO （Retransmission Timeout 超时重传时间）如何设置？

######### 过长

########## 空隙时间增大，降低网络的传输效率

######### 过短

########## 增加不必要的数据发送，导致网络负荷增大

######### RTT（Round-Trip Time 往返时延）

########## 数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间

######### 超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。

########## 在实际的网络环境中，网络的状态是随时变化的，RTT的值也不是一个固定不变的数，相应的，RTO也应该是一个动态的值

####### 快速重传

######## 超时重传的时间周期可能相对过长，快速重传机制不以时间为驱动，而以数据为驱动重传

######## 举例说明

######### ack确认应答时不以接受到的数据的序列号+1.而是发送希望收到的序列号的ack；发送端在收到三个相同的ack之后会明白这个序列的报文丢失了，于是重传该报文。接收方收到丢失的报文就会返回下一次希望收到的序列号的ack

######## 解决的超时重传的问题

######### 不会有超时重传那么长的时间周期

######## 面临的问题

######### 重传的时候，是重传一个，还是重传所有的报文

########## 举例说明

########### 当发送端发出的报文中有两个报文丢失了，接收端回复三个一样的报文，发送端是重传丢i是的第一个报文，还是把后续所有的报文都重传？

############ 如果只重传丢失的第一个报文，那丢失的第二个报文需要等到接下来三个相同的ack后才能重传

############# 重传的效率很低

############ 如果全部重传，确实能够把丢失的报文都重传过去，但是被成功接受到的报文也会被重传一遍

############# 浪费网络资源

####### SACK

######## （ Selective Acknowledgment）选择性确认

######### 解决快速重传不知道重传哪些报文的问题

######## 在TCP首部的选项字段添加SACK，接受端将收到哪些数据包的信息放在里面

######### 发送端可以根据该字段知道哪些包丢失了，只重传丢失的数据包

######## 如果要支持SACK，需要通信的双方都支持

######### 在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。

####### D-SACK

######## 使用SACK来告知发送端哪些报文被重复接受了

######## 作用

######### ACK丢失

########## 接受方的ack都发生丢失的情况下，在 收到重复的报文会在SACK中告知已经接受到的报文

########### 发送方就会得知数据没有得知，是ack回应丢失

######### 网络延迟

########## 发送方发出的数据被网络延迟了，接受方回应三个相同的ack触发发送方的快速重传机制，发送方查看SACK知道要重传的数据包是哪个

########## 发送方被延迟的数据在后续被接收方接受到，触发D-SACK，告知接收到重复的包

########## 发送方得知触发快速重传的原因不是包丢了也不是ack丢了，是因为网络延迟了

######## 好处

######### 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;

######### 可以知道是不是「发送方」的数据包被网络延迟了;

######### 可以知道网络中是不是把「发送方」的数据包给复制了

###### 滑动窗口

####### 窗口

######## 引入窗口概念的原因

######### 确认应答机制的效率低

########## 确认应答为每个数据包回复一个ack，数据包的往返时间长，通信效率低

######## 实现

######### 操作系统开辟一片缓存空间，发送端在发送数据时，可以无需等待确认应答，继续发送数据，发送数据的大小不能超过窗口大小，发送端在等到接收端确认应答回复之前，必须在发送缓存保留发生的数据，只有等到收到ack之后才可以从缓存中删除

######## 累计确认/累计应答

######### 由于窗口的机制，发送端可以在发生数据时可以无需等待ack回应，直接发送窗口大小那么大的数据包，接收端返回的ack回应即使丢失了也不会发送重传，发送端可以通过收到的下一个ack回应得出数据是否有丢失

######## 窗口大小的确认

######### TCP首部的窗口大小字段(16位)

######### 由接收端来决定窗口大小

######### 接收端通过窗口大小字段告知发送端自己还有多少缓冲区，发送端按照这个缓冲区大小来发送数据，这样不会导致接收端处理不过来

####### 发送窗口

######## 分为四个部分

######### 1. 已发送并收到ack回应的数据

######### 2. 已发送未收到ack回应的数据

######### 3. 未发送但在接收端窗口大小范围内的数据

######### 4. 未发送且不在接收端窗口大小范围内的数据

######## 滑动实现方案

######### 三个指针

########## SND.WND：表示发送窗口的大小（大小是由接收方指定的）；

########## SND.UNA（Send Unacknoleged）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。

########## SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。

######### 可用窗口大小

##########  SND.WND -（SND.NXT - SND.UNA）

####### 接受窗口

######## 分为三个部分

######### 1. 已成功接受并确认的数据

######### 2. 未收到数据，但可以接受的数据

######### 3. 未收到数据，且不可以接受的数据

######## 滑动实现方案

######### 两个指针

########## RCV.WND：表示接收窗口的大小，它会通告给发送方。

########## RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #2 的第一个字节。

####### 发送窗口和接受窗口的大小一致吗

######## 接受窗口的大小并不是一成不变的，新的接受窗口大小通过TCP报文的首部Window字段告知发送端，报文传输存在时延，所以发送窗口和接受窗口的大小是一个约等于 的关系

###### 流量控制

####### 操作系统缓冲区与滑动窗口的关系

######## 当应用层程序没有及时读取系统缓存时，数据留在了缓冲区，接受窗口收缩并告知发送端

######## 系统繁忙的时候操作系统直接缩小的接受缓冲区，接收端告知发送端窗口大小变化，发送端在收到此通知前按照之前约定的窗口大小继续发送数据，导致发送的数据大于现在的接受窗口大小，数据直接丢弃

######### 并且，发送端在收到窗口大小变化之后，尝试将发送窗口向左收缩，但此时已经发出了待ack回应的报文，发送窗口可用值就会出现诡异的负值

######## 防止第二种情况出现，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。

####### 窗口关闭

######## 如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止

######## 接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，就会形成死锁。

######## 为解决死锁问题

######### TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。

######### 如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文

######### 对方在确认这个探测报文时，给出自己现在的接收窗口大小。

########## 如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器

########## 如果接收窗口不是 0，那么死锁的局面就可以被打破了。

####### 糊涂窗口综合症

######## 如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节

######### 由于TCP首部+IP首部占60个字节，发送小数据的开销过大

######## 糊涂窗口综合症的现象是可以发生在发送方和接收方：

######### 接收方可以通告一个小的窗口

######### 而发送方可以发送小数据

######## 接收方不通告小窗口策略

######### 当「窗口大小」小于 min( MSS，缓存空间/2 ) 

########## 就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。

######### 等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用

########## 把窗口打开让发送方发送数据过来。

######## 发送方避免发送小数据策略

#########  Nagle 算法

########## 思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：

########### 条件一：要等到窗口大小 >= MSS 并且 数据大小 >= MSS

########### 条件二：收到之前发送数据的 ack 回包

######### Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。

######### 在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）

###### 拥塞控制

####### 慢启动

######## TCP刚建立连接，不能直接发送大量数据包，慢启动是一点一点增大发包的数量

######## 规则

######### 当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。

########## 发包的个数是指数性的增长

######## 门限ssthresh （slow start threshold）

######### 当 cwnd < ssthresh 时，使用慢启动算法。

######### 当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」

####### 拥塞避免

######## 规则

######### 每当收到一个 ACK 时，cwnd 增加 1/cwnd。

########## 发包的个数变成线性增长

####### 拥塞发生

######## 触发重传机制进入拥塞发生

######### 超时重传的拥塞发生算法

########## 当发生超时重传

########### 将ssthresh置为cwnd拥塞窗口的二分之一

########### cwnd拥塞窗口重置为1

########### 进入慢启动

######### 快速重传的拥塞发生算法

########## 当发生快速重传

########### 1. cwnd拥塞窗口变为现在的一半

########### 2. ssthresh门限值变为现在cwnd

########### 进入快恢复

####### 快恢复

######## 拥塞窗口cwnd = ssthresh + 3

######### 快速重传的拥塞发生是因为收到三个相同的ack

######## 重传丢失的数据包

######## 如果再收到重复的 ACK，那么 cwnd 增加 1；

######## 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值

######### 重新进入拥塞避免状态

##### MSS TCP最大报文段长度

###### 如果直接传输的数据过大，不利于控制，因此传输层的数据包大小超过MSS后，要进行分块

####### 好处

######## 如果发生分块丢失或损坏，只需要重新发这一个分块，而不用全部重发

#### UDP

##### 只负责发送数据包，不保证数据是否能够递达对方

###### 优点 

####### 实时性更好，传输效率更高

###### 缺点

####### 可靠性低

######## UDP实现可靠传输：在应用层实现TCP特性

### 网际层

#### IP Internet Protocol

##### MTU(以太网中一般为1500字节)

###### IP报文{IP首部, 传输层的报文}超过MTU会再次进行分片

##### IP路由

###### 实际场景中两台设备不是一条网线一连到底的，中间经过了很多网络设备进行连接。而数据包如何有效的到达目的设备，需要通过路由算法来决定走哪条路径

####### 路由算法

##### IP基本认识

###### IP的作用

####### 实现点到点通信(主机到主机)

######## 传输层只负责端到端的通信，对于数据在网络中如何传输，路由怎么选择，对传输层来说是透明的，实际的数据传输功能交给网际层完成

###### IP与MAC的关系

####### MAC的作用是实现【直连】两个【设备】之间的通信

####### IP负责在【没有直连】的两个【网络】之间通信

####### 在实际的数据传输中，【源IP和目的IP在传输过程中是不会变化的(没有使用NAT网络)，只有源MAC和目的MAC一直发生变化

##### IP地址的基础知识

###### IP地址的定义

####### IPv4由32位正整数表示，在计算机内部是以二进制的方式进行处理的

####### IP地址的最大值位2^32 约等于43亿

######## 最大允许43亿台计算机连接到网络

######### 实际上，IP地址不是根据主机台数来配置的，而是以网卡。一个网卡占用一个IP地址

######### IP地址由网络号+主机号组成，能连接到网络的主机数量只会更少

######## NAT技术

###### IP地址的分类

####### 分类地址

######## A类地址

######### 1.0.0.0 ~ 127.255.255.255

########## 大量主机，公网

########## 127.0.0.1 localhost环回地址

########### 环回地址不会流向网络

######### 最大主机数: 2^24 - 2

######## B类地址

######### 128.0.0.0 ~ 191.255.255.255

########## 国际大公司，政府

######## C类地址

######### 192.0.0.0 ~ 223.255.255.255

########## 小公司，校园网，科研单位

######## D类地址

######### 224.0.0.0 ~ 239.255.255.255

########## 组播

######## E类地址

######### 240.0.0.0~255.255.255.255

########## 保留

########## 受限广播地址

########### 用于本网广播

########### 255.255.255.255

####### 广播地址

######## 主机号全为1

######## 用于什么？

######### 同一个链路中相互连接的主机之间发生数据包

######## 分类

######### 本地广播

######### 直接广播

########## 在不同网络之间广播

########### 有一定的安全问题，多数情况下在路由器设置为不转发

####### 多播地址

######## D类地址的前4位1110表示多播地址，剩下28位是多播的组编号

######## 用于什么？

######### 将包发给特定组内的所有主机

######## 分类

######### 预留的组播地址

########## 224.0.0.0 ~ 239.255.255.255

########### 只能在局域网中，路由器是不会进行转发

######### 用户可用的组播地址

########## 224.0.1.0 ~ 238.255.255.255

########### 可以用于Internet上

######### 本地管理组播地址

########## 239.0.0.0 ~ 239.255.255.255

########### 可供内部网在内部使用，仅在特定的本地范围内有效

####### IP分类的优缺点

######## 优点

######### 可以通过IP地址很容易判断是什么类型的地址

######## 缺点

######### 同一网络下没有地址层次

######### C类和B类地址的最大主机数量不能很好的与现实网络匹配

###### 无分类IP地址(CIDR)

####### 网络号

######## 标识IP地址是属于哪一个【子网】的

######### 子网掩码

########## 网络地址置为1，主机地址置为0

########## 求某主机的网络地址(对外的ip地址)

########### 某主机ip地址&子网掩码

####### 主机号

######## 标识同一子网下的不同主机

####### 子网划分

###### 公有IP地址与私有IP地址

####### 在 A、B、C 分类地址，实际上有分公有 IP 地址和私有 IP 地址。

###### IP地址与路由控制

####### IP地址的网络地址这一部分是用于进行路由控制

####### 在发生IP包时，首先确定IP包首部的目标地址，再从路由控制表找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器，如果路由器中存在多条相同网络地址的记录，就选择相同位数最多的网络地址(最长匹配)

###### IP分片与重组

####### 分片

######## 根据数据链路的类型不同，MTU也不尽相同

######### 以太网MTU 1500字节

######## TODO为什么IP有分片了，TCP还要进行分块

######### 在分片传输中，一旦某个分片丢失，会造成整个IP数据报作废，

####### 重组

######## 只能由目标主机进行重组，路由器不会进行重组

###### IPv6基本认识

###### IPv4首部与IPv6首部

##### IP协议相关技术

###### DNS域名解析

####### 作用

######## 将域名网址自动转换为具体的IP地址

####### 在域名中，越靠右的位置表示其层级越高

######## 层级关系

######### 根DNS服务器

######### 顶级域DNS服务器

######### 权威DNS服务器

######### ...

####### 域名解析工作流程(以www.server.com)

######## 1. 浏览器首先看自己的缓存中有没有

######## 2. 向操作系统的缓存要

######## 3. 检查本机域名解析文件hosts

######## 4. 向DNS服务器进行查询

######### 4.1 向本地DNS服务器发出一个DNS请求

######### 4.2 本地DNS服务器查询自己的缓存，如果有直接返回IP地址

######### 4.3 本地DNS服务器问它的根域名服务器（根域名服务器是最高层级的，不能直接用于域名解析，但能指一条明路）

######### 4.4 根DNS服务器收到本地DNS服务器请求，返回.com顶级域名服务器的地址

######### 4.5 本地DNS服务器向.com域名服务器发起请求

######### 4.6 .com顶级域名服务器收到本地DNS服务器请求，返回www.server.com区域的权威DNS服务器地址

######### 4.7 本地DNS服务器向权威DNS服务器发起请求

######### 4.8 权威DNS服务器查询后将对应的IP地址告诉本地DNS服务器(权威域名服务器是域名解析结果的出处)

######### 4.9 本地DNS服务器再将IP地址返回给客户端，客户端和目标建立连接

###### ARP与RAPR协议

####### ARP

######## 作用

######### 在传输IP数据报时，确定了源IP和目的IP，通过主机的路由表确定下一跳的IP地址，但在物理链路中传输是直连两个设备之间的通信，需要知道下一跳的MAC地址

######## 通过ARP请求和ARP响应两种类型的包确定MAC地址

######## 工作流程

######### 主机广播发送ARP请求，请求包中目的MAC为空

######### 同个链路中的所有设备收到ARP请求后，去比对目的IP与自己的IP是否一致，如果一致返回ARP响应包，传回自己的MAC地址

######### 主机将第一次通过ARP获得的MAC地址缓存起来，以便下次直接从缓存中找到对应的IP地址

####### RARP

######## 作用

######### 已知MAC地址求IP地址

######## 应用场景

######### 小型嵌入式设备接入到网络时用到

###### DHCP动态获取IP地址

####### 工作流程

######## 1. 客户端通过广播发送DHCP发现报文(DHCP Discover)

######### 源IP为0.0.0.0 目的IP为255.255.255.255

######## 2. DHCP服务器用DHCP提供报文(DHCP Offer)向客户端返回响应

######### 源IP为DHCP服务器地址，目的IP仍然是255.255.255.255受限广播

########## 携带可租约的IP地址，子网掩码，DNS服务器地址，默认网关以及IP地址的租用期

######## 3. 客户端收到一个或多个DHCP服务器发来的Offer，从中选择一个，向选择的DHCP服务器发送DHCP请求报文(DHCP Request)

######### 回显配置参数

######## 4. DHCP服务器用DHCP ACK应答报文回应客户端，应答所要求的配置

######## 全程使用UDP广播通信

######### 如果当前局域网没有DHCP服务器，路由器不转发受限广播包，怎么办？

########## DHCP中继代理

########### 客户端向DHCP中继代理发送DHCP请求包，中继代理以单播转发给DHCP服务器

###### NAT网络地址转换

####### 网络地址与端口转换NAPT

######## 作用

######### 可以将局域网内两个不同的私有地址映射到同一个公有地址，以端口号来进行区分

######## NAPT转换表在NAT路由器上自动生成

######### 例如，建立TCP连接的首个SYN报文一经发出，就会生成对应的表记录，随着关闭连接的FIN报文删掉该记录

######## 缺点

######### 外部无法主动与内部网络进行通信，因为NAPT转换表没有相应的记录

######### 转换表的生成和转换都会产生性能开销

######### 通信过程中，如果NAT路由器重启了，相应的连接都将会被重置

######## 解决办法

######### 使用IPv6

######### NAT穿透技术

###### ICMP互联网控制报文协议

####### 主要功能

######## 确认 IP 包是否成功送达目标地址

######## 报告发送过程中 IP 包被废弃的原因和改善网络设置

####### 两类报文

######## 查询报文类型

######## 差错报文类型

####### Ping的工作流程

######## Ping应用程序是基于ICMP协议实现的，用来测试两台主机的连通性

######## 工作原理

######### 向目的主机发送ICMP Echo Request查询报文，目的主机返回ICMP Echo Reply查询报文，通过时间和响应次数来算出两台主机之间的数据包往返时间和丢包率

######## ping的工作流程实际上就是ICMP数据包的发送和解析的过程

######### 1. 构建ICMP数据包（ICMP Echo Request）

######### 2. 构造IP数据包

########## ICMP数据包作为IP数据报的报文内容，要测试连接的IP地址作为目的IP，填充源IP为本机IP

######### 3. 构造以太网数据帧

########## 根据本地ARP缓存查找目的地址IP对应的MAC地址，如果缓存中没有则通过ARP协议对应IP的MAC地址，将MAC地址交给数据链路层构造以太网数据帧

######### 4. 通过物理链路传输到目标主机

######### 5. 获取以太网数据帧

########## 物理层接收到二进制数据流经数据链路层，按照以太网协议解析出数据帧，如果数据帧中的目标MAC地址与本机MAC地址相同，则接收该数据包，否则丢弃该数据包。

######### 6. 解析出IP数据包

######### 7. 解析出ICMP数据包

######### 8. 发送ICMP Echo Reply报文

###### IGMP因特网组管理协议

####### 组播向一组主机发送数据包，通过IGMP协议管理组

######## 工作在主机(组播成员)和最后一跳路由器之间

####### 工作流程

######## IGMP 报文向路由器申请加入和退出组播组

######### 默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过 IGMP 加入到组播组

######### 主机申请加入到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机

#### 网关

##### 连接两个不同网络的设备都可以叫做网关

### 网络接口层

#### 为网络层提供【链路级别】传输的服务

#### 网卡工作在网络接口层。使用MAC地址来标识网络上的设备

## 套接字编程

### 同步，异步，阻塞，非阻塞

#### 同步与异步

##### 同步

###### 在发出一个调用时，在没有得到结果之前，该调用就不返回。
但是一旦调用返回，就得到返回值了。
换句话说，就是由调用者主动等待这个调用的结果。

##### 异步

###### 当一个异步调用发出后，调用者不能立刻得到结果。
被调用者（实际处理这个调用的对象）在处理完成后，
通过状态、通知调用者，或通过回调函数来通知调用者。

#### 阻塞与非阻塞

##### 阻塞

###### 阻塞调用是指调用结果返回之前，当前线程会被挂起，
不占用系统资源。调用线程只有在得到结果之后才会返回。

##### 非阻塞

###### 在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

#### 同步和异步关注的是消息通信机制

#### 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。

### 阻塞IO

#### API

##### 通过进程启动 Winsock DLL 的使用

###### int WSAStartup(
	    WORD      wVersionRequired,
  [out] LPWSADATA lpWSAData
);

####### 参数说明

######## wVersionRequired

######### TBD

######## [out] lpWSAData

######### 指向 WSADATA 数据结构的指针，该结构用于接收 Windows 套接字实现的详细信息。

##### 创建套接字

###### SOCKET WSAAPI socket(
  [in] int af,
  [in] int type,
  [in] int protocol
);

####### 参数说明

######## af

######### 地址族规范

########## AF_INET

########### （IPv4） 地址系列

########## AF_INET6

########### （IPv6） 地址系列

######## type

######### 套接字的类型规范

########## SOCK_STREAM

########### 使用传输控制协议 （TCP）

########## SOCK_DGRAM

########### 使用用户数据报协议 （UDP）

######## protocol

######### 要使用的协议

########## IPPROTO_TCP

########### 传输控制协议 （TCP）

########## IPPROTO_UDP

########### 用户数据报协议 （UDP）

###### 设置套接字选项

####### int WSAAPI setsockopt(
  [in] SOCKET     s,
  [in] int        level,
  [in] int        optname,
  [in] const char *optval,
  [in] int        optlen
);

######## 参数说明

######### [in] s

########## 标识套接字的描述符

######### [in] level

########## 选项定义的级别，例如，SOL_SOCKET

######### [in] optname

########## 要为其设置值的套接字选项 (，例如，SO_BROADCAST)

######### [in] optval

########## 指向在其中指定所请求选项值的缓冲区的指针

######### [in] optlen

########## optval 参数指向的缓冲区的大小

###### 检索套接字选项

####### 函数原型

######## int WSAAPI getsockopt(
  [in]      SOCKET s,
  [in]      int    level,
  [in]      int    optname,
  [out]     char   *optval,
  [in, out] int    *optlen
);

######### 参数说明

########## [in] s

########### 标识套接字的描述符

########## [in] level

########### 选项定义的级别，例如，SOL_SOCKET

########## [in] optname

########### 要为其检索值的套接字选项

########## [out] optval

########### 一个指向缓冲区的指针，在该缓冲区中，将返回所请求的选项的值。

########## [in, out] optlen

########### 指向 optval 缓冲区的大小（以字节为单位）的指针。

##### 将本地地址与套接字相关联

###### int WSAAPI bind(
  [in] SOCKET         s,
  [in] const sockaddr *name,
  [in] int            namelen
);

####### 参数说明

######## [in] s

######### 标识未绑定套接字的描述符。

######## [in] name

######### 指向要分配给绑定套接字的本地地址的 sockaddr 结构的指针。

######## [in] namelen

######### 第二个参数的长度

####### struct sockaddr {
	    ushort  sa_family;
	    char    sa_data[14];
};

struct sockaddr_in {
	    short   sin_family;
	    u_short sin_port;
	    struct  in_addr sin_addr;
	    char    sin_zero[8];
};

######## 通常使用sockaddr_in结构体

######### 因为端口号和ip地址都是单独的变量，方便赋值，使用时强转为sockaddr*

######## 成员变量说明

######### sin_family

########## 传输地址的地址族，通常为AF_INET

######### sin_port

########## 传输协议端口号

########## htons

########### 将整型变量从主机字节序变为网络字节序

######### sin_addr

########## IN_ADDR结构体

########### struct in_addr {
	union {
	    struct {
	        u_char s_b1;
	        u_char s_b2;
	        u_char s_b3;
	        u_char s_b4;
	     } S_un_b;
	     struct {
	         u_short s_w1;
	         u_short s_w2;
	      } S_un_w;
	     u_long S_addr;
	} S_un;
};

########## inet_ntoa

########### 将IPv4网络地址转换成标准点分十进制格式的ASCII码字符串

######### sin_zero

########## 保留供系统使用

##### 接受数据API

###### 从连接的套接字或绑定的无连接套接字接收数据

####### recv

######## 函数原型

######### int WSAAPI recv(
  [in]  SOCKET s,
  [out] char   *buf,
  [in]  int    len,
  [in]  int    flags
);

######## 参数说明

######### [in] s

########## 标识连接的套接字的描述符

######### [out] buf

########## 接收传入数据的缓冲区的指针

######### [in] len

########## 缓冲区的长度

######### [in] flags

########## 影响此函数行为的标志

######## 返回值说明

######### > 0

########## 接收到的数据的大小

######### = 0

########## 连接正常关闭

######### SOCKET_ERROR(-1)

########## 发生错误

###### 接收数据报，并存储源地址

####### recvfrom

######## 函数原型

######### int WSAAPI recvfrom(
  [in]                SOCKET   s,
  [out]               char     *buf,
  [in]                int      len,
  [in]                int      flags,
  [out]               sockaddr *from,
  [in, out, optional] int      *fromlen
);

######## 参数说明

######### [in] s

########## 标识绑定套接字的描述符。

######### [out] buf

########## 传入数据的缓冲区。

######### [in] len

########## buf 参数指向的缓冲区的长度

######### [in] flags

########## 用于修改函数调用的行为

######### [out] from

########## 指向 sockaddr 结构中缓冲区的可选指针，将在返回时保存源地址

######### [in, out, optional] fromlen

########## 消息来源方socket的大小

######## 其实是从内核接受缓冲区将数据复制到自己的缓冲区

######### 内核接受缓冲区默认大小:64KB

##### 发生数据API

###### 将数据发送到特定目标

####### sendto

######## 函数原型

######### int WSAAPI sendto(
  [in] SOCKET         s,             
  [in] const char     *buf,    
  [in] int            len,                   
  [in] int            flags,                  
  [in] const sockaddr *to,  
  [in] int            tolen                 
);

########## 参数说明

########### [in] s

############ 套接字的描述符。

########### [in] buf

############ 要传输数据的缓冲区的指针

########### [in] len

############  //数据长度

########### [in] flags

############ 指定调用的进行方式

########### [in] to

############ 目标套接字地址的 sockaddr结构的可选指针

########### [in] tolen

############ 指向的地址的大小

######## 其实是将数据发送到发送缓冲区

######### 发送缓冲区默认大小: 64KB

###### 在连接的套接字上发送数据

####### send

######## 函数原型

######### int WSAAPI send(
  [in] SOCKET     s,
  [in] const char *buf,
  [in] int        len,
  [in] int        flags
);

######## 参数说明

######### [in] s

########## 连接的套接字的描述符

######### [in] buf

########## 包含要传输的数据的缓冲区的指针

######### [in] len

##### 关闭现有套接字

###### int WSAAPI closesocket(
  [in] SOCKET s
);

##### 终止使用 Winsock 2 DLL (Ws2_32.dll) 

###### int WSAAPI WSACleanup();

####### 返回值

######## 操作成功，则返回值为零

######## 否则，返回值SOCKET_ERROR

######### 通过调用 WSAGetLastError 来检索特定的错误号

##### 将套接字置于侦听传入连接的状态

###### 函数原型

####### int WSAAPI listen(
  [in] SOCKET s,
  [in] int    backlog
);

###### 参数说明

####### [in] s

######## 标识绑定的未连接套接字的描述符

####### [in] backlog

######## 挂起连接队列的最大长度

######### SOMAXCONN

########## 设置为最大合理值

##### 允许在套接字上尝试传入连接

###### 函数原型

####### SOCKET WSAAPI accept(
  [in]      SOCKET   s,
  [out]     sockaddr *addr,
  [in, out] int      *addrlen
);

###### 参数说明

####### [in] s

######## 一个描述符，用于标识已使用 侦听 函数处于侦听状态的套接字。 连接实际上是使用 接受返回的套接字建立的

####### [out] addr

######## 指向接收连接实体地址（称为通信层）的缓冲区的可选指针

####### [in, out] addrlen

######## 指向包含 addr 参数指向的结构长度的整数的可选指针。

##### 建立与指定套接字的连接

### 非阻塞IO

#### API

##### 控制套接字的 I/O 模式

###### int WSAAPI ioctlsocket(
  [in]      SOCKET s,
  [in]      long   cmd,
  [in, out] u_long *argp
);

####### 参数说明

######## [in] s

######### 套接字的描述符

######## [in] cmd

######### 在 套接字上执行的命令。

######## [in, out] argp

######### 指向 cmd 参数的指针

### 阻塞和非阻塞下IO的区别

#### recvfrom

##### 阻塞模式

###### 一直等待数据的到来，再继续往下执行

##### 非阻塞模式

###### 无论是否有数据到来都立即返回

#### sendto

##### 阻塞模式

###### 如果发送缓存区没有足够的空间大小，就等待空间足够大了再放入

##### 非阻塞模式

###### 只要有数据就放入到发送缓冲区，能放多少放多少，放完立即返回，返回放入的字节大小

### UDP数据报的特点

#### 1. 只要有数据放入到发送缓冲区，就直接发送出去，然后就从缓冲区中删掉

##### 发送的数据不会在缓冲区在停留

##### 即使发送失败也没办法重发

#### 2. 数据不可拆分，接到多少，剩下的就抛弃了

#### 3. 如果发送端发送字节数 < 接收端自定义接受缓冲区大小，收到数据直接返回，有多少接多少，不会等待缓冲区填满
​```(end)
```