

![](https://raw.githubusercontent.com/Cris-Cui/ImagesForBlog/master/Blog/20230810182639.png)

# 应用层

## HTTP基础概念

HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。

### HTTP状态码

![ 五大类 HTTP 状态码 ](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png)

### HTTP 常见字段

**请求包：**

*Host* 字段：客户端发送请求时，用来指定服务器的域名。

*Connection 字段*：客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。

- HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。

*Accept 字段*:  客户端请求的时候声明自己可以接受哪些数据格式。

*Accept-Encoding 字段* ： 客户端请求的时候说明自己可以接受哪些压缩方法

**响应包：**

*Content-Length 字段*：服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。

- 解决沾包问题：**设置回车符、换行符作为 HTTP header 的边界；通过 Content-Length 字段作为 HTTP body 的边界**

*Content-Type 字段*：服务器回应时，告诉客户端，本次数据是什么格式。

- ```text
	Content-Type: text/html; Charset=utf-8 // 表明，发送的是网页，而且编码是UTF-8。
	```

*Content-Encoding 字段*：表示服务器返回的数据使用了什么压缩格式

### 请求报文的方法

| 方法(操作) |                含义                |
| :--------: | :--------------------------------: |
|    GET     |        请求读取一个Web页面         |
|    POST    |          请求报文附带数据          |
|   DELETE   |            删除Web页面             |
|  CONNECT   |           用于代理服务器           |
|    HEAD    |     请求读取一个Web页面的首部      |
|    PUT     |        请求存储一个Web页面         |
|   TRACE    | 用于测试，要求服务器送回收到的请求 |
|   OPTION   |            查询特定选项            |

#### Get和Post的区别?

Get(只读操作)：是请求获取指定的资源。安全、幂等、可被缓存的。

- 从服务器获取指定的资源，可以是静态的页面，图片视频等。Get请求的参数一般写在URL中，然后URL只支持ASCII码，所以Get请求的参数只允许ASCII字符.

Post: 根据请求数据包的body部分的内容对指定的资源做处理。不安全，不幂等，（大部分实现）不可缓存。

- body可以是任意格式的数据，只要客户端和服务端协商好，比如说提交表单就可以用可以用POST请求

**安全**:请求方法不会「破坏」服务器上的资源。

**幂等**:多次执行相同的操作，结果都是「相同」的。

并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。

### HTTP缓存技术

对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都**缓存在本地**，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。

#### 强制缓存

两个 HTTP 响应头部（Response Header）字段实现的：表示资源在客户端缓存的有效期：

- `Cache-Control`， 是一个相对时间；
- `Expires`，是一个绝对时间；

 Cache-Control 来实现强缓存：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
- 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
- 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。

#### 协商缓存

某些请求的响应码是 `304`，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png)

## HTTP/1.1

优点：简单、灵活和易于扩展、应用广泛和跨平台

缺点：无状态、明文传输(这是优缺点双刃剑),一大缺点「不安全」

**无状态双刃剑**

- 无状态的好处: 服务器不去记忆HTTP的状态，不需要额外的资源来维护记录。降低了服务器的负载，能把更多的CPU和内存用来对外提供服务。

- 无状态的坏处: 服务器没有记忆能力，完成关联性操作会非常麻烦。

	**解决方案: ** **Cookie技术**

	- Cookie是客户端技术，服务器把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的Cookie去。这样，Web服务器通过读取Cookie就可以获得每个用户保存的数据了
	- Session是服务器端技术，当用户访问服务器的某个资源时，服务器可以为每一个用户的浏览器创建一个其独享的session对象，并将用户的数据存放在各自的session域中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。

**明文传输双刃剑**

可方便阅读的，但**信息裸奔**

**不安全**

- 通信使用明文（不加密），内容可能会被窃听。比如，**账号信息容易泄漏，那你号没了。**

- 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多，那你钱没了。**

- 无法证明报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告，视觉污染，眼没了。**

### 性能

​	相较于HTTP/1.0来说，1.1是基于TCP**长连接**的，这样做的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务端的负载。

***管道网络传输***

可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**但是**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**。

> 如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。
>
> 所以，**HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。
>
> 实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持

## HTTP和HTTPS

HTTP是超文本传输协议，传输的信息是明文的，存在安全风险的问题， HTTPS则是为了解决HTTP的不安全的缺陷，体现在：

1. 窃听的风险，对传输的数据是明文的，未加密的，他人可以直接在通信链路上获取通信内容。
2. 纂改的风险，没有报文完整性校验，如果被纂改比如说植入垃圾广告
3. 冒充的风险，没有对服务器进行单向认证，可能会遇到一个假服务器冒充你请求的服务器。

HTTPS在HTTP的基础上加了SSL/TLS协议，可以很好的解决上述的三个风险

- 信息加密：混合加密实现信息的机密性
- 校验机制：摘要算法实现完整性，无法篡改通信内容
- 身份证书：把服务器公钥放到数字证书中解决冒充的风险

**具体实现**

1. 混合加密：在通信建立前采用**非对称加密**交换**对称加密的会话密钥**，后续对称加密的会话密钥加密明文数据

	采用混合加密的原因:

	- 对称加密只使用一个密钥，虽然运算速度快，密钥必须保密无法做到安全交换。

	- 非对称加密使用两个密钥，公钥和私钥，公钥可以任意分配而私钥保密，解决密钥的安全交换问题，但是速度慢。

2. 摘要算法+数字签名：

	使用摘要算法（哈希函数）可以验证数据内容是否在发送前后一致，但是无法解决【数据内容+哈希值】一起被篡改，客户端缺少对该数据是否来自服务端的证明。所以使用刚才讲的非对称加密来确认消息的身份

	- **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
	- **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

	在这里使用**私钥加密摘要算法产生的哈希值**，公钥解密，如果能正常解密，证明数据是私钥人发的。

	即数字签名为对数据内容通过摘要算法产生的哈希值的一个私钥加密的结果，将他和内容一起发送出去，接收端在收到后，对收到的数据部分通过同样的摘要算法进行运算，得到一个哈希值，再用公钥对数字签名进行解密，得到一个哈希值进行比较来实现数据内容的完整性校验。

3. 数字证书

	前面通过公钥解密数字签名来保证消息来源的可靠，但是缺少身份验证环节，公钥可能是伪造的。

	可以通过CA机构将服务器信息，公钥，数字签名打包成一个数字证书，只要CA机构是权威可信的，公钥就是可信的，解决服务器冒充的风险

## HTTPS握手过程

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

前两部就是TLS**握手过程**

主要涉及4次通信：

对对称加密的会话密钥进行非对称加密的密钥交换，常使用的有两种：RSA算法和ECDHE算法

前置条件： 先TCP三次握手建立连接

1. 客户端发送Hello报文，包括了一个随机数，自己的TLS版本号，自己有哪些密码套件列表
2. 服务端收到Hello报文，对客户端也发送Hello响应，包括确认使用哪个TLS版本号，如果服务端不支持就关闭加密通信；服务区产生的随机数，服务器确认的密码套件列表，RSA加密算法，服务器的数字证书
3. 客户端收到服务器的Hello报文后，通过浏览器内置的CA公钥，确认服务器的数字证书的真实性，如果没有问题，取出公钥，用它加密报文，向服务器发送：一个随机数（被公钥加密）加密通信算法改变通知，之后用会话密钥通信；客户端握手结束通知
4. 服务器收到客户端的第三个随机数后，通过协商的算法，计算出本次会话密钥 三个随机数-》会话密钥。最后向客户端发最后的消息：（1）加密通信算法改变通知，随后的信息都将用会话密钥加密通信，握手结束

# 传输层

## TCP

### 面向连接的，可靠的，基于字节流的

#### 面向连接的

一对一建立连接才能通信。**用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket(IP+Port)、序列号(解决乱序)和窗口大小(流量控制)称为连接。**

#### 可靠的

无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；

#### 字节流

用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

可以理解为一个双向的通道里流淌的数据(01bit位)而纯裸的TCP是没有任何边界的，这就会导致沾包问题，需要在这个基础上加入一些**自定义的规则**，用于区分**消息边界**。

于是我们会把每条要发送的数据都包装一下，比如加入**消息头**，**消息头里写清楚一个完整的包长度是多少**，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的**消息体**。提到的**消息头**，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的**协议。**

基于 TCP 造出来的 HTTP 和**各类** RPC 协议，它们都只是定义了不同消息格式的**应用层协议**而已。

### 如何确定一个唯一的TCP连接?

TCP 四元组可以唯一的确定一个连接，四元组包括如下：

- 源地址
- 源端口
- 目的地址
- 目的端口

对 IPv4，客户端的 IP 数最多为 `2` 的 `32` 次方，客户端的端口数最多为 `2` 的 `16` 次方，也就是服务端单机最大 TCP 连接数，约为 `2` 的 `48` 次方。

当然，服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：

- 文件描述符限制

	，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：

	- **系统级**：当前系统可打开的最大数量，通过 `cat /proc/sys/fs/file-max` 查看；
	- **用户级**：指定用户可打开的最大数量，通过 `cat /etc/security/limits.conf` 查看；
	- **进程级**：单个进程可打开的最大数量，通过 `cat /proc/sys/fs/nr_open` 查看；

- **内存限制**，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。

### UDP 和 TCP 有什么区别呢？分别的应用场景是？

UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。

UDP 协议真的非常简，头部只有 `8` 个字节（64 位）[源端口 + 目的端口 + 包长度+ 校验和]



# 网络层

# 数据链路层

# 物理层

