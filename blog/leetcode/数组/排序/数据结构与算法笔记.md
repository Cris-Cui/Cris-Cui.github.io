# [时间复杂度]()
## 复杂度计算规律
1. 复杂度与具体的常数无关
2. 多项式级的复杂度，只保留最大的一项
3. 若一段程序可以在有限可数的资源消耗(与输入的数据量n无关)内完成, 复杂度记为O(1)
## 关于复杂度的经验性结论
1. 一个顺序结构的代码，时间复杂度是O(1)
2. 采用分治法的二分策略，时间复杂度是O(logn)
3. 一般简单的for循环，时间复杂度是o(n)
4. 两个顺序执行的for循环，时间复杂度是取高项
5. 两层for循环，时间复杂度是O(n^2)
> T(n) = aT(n/b) + f(n)

# 线性数据结构
> 数组array , 链表List , 队列queue , 栈stack , 串 string

## 线性结构的基本特征
- 线性结构是一个数据元素的有序（次序）的集合
- 集合中必存在唯一一个“第一元素”
- 集合中必存在唯一一个“最后元素”
- 除最后元素在外，均有唯一后继
- 除第一元素之外，均有唯一前驱
### 顺序和链式区别:
1.数组连续/链表不一定连续
2.空间扩容 数组先申请更大的空间,再将原内容拷贝至新的空间 链表无限扩容
3.增/删 数组头和中插O(n) 尾插空间够O(1)不够是O(n) 链表 头是O(1) 中尾是O(n) 数组删除 已知索引O(1) 未知O(n) 链表删除 头是O(1) 中尾是O(n)
4.查 数组基于索引的搜索O(1) 有序可以二分减小复杂度 无序O(n) 链表都是O(n)

## 数组Array
> 类型相同，空间连续的结构
int arr[5] = {1,2,3,4,5};
arr 名字：一般：首元素首地址 不可以arr++ arr 常量
特殊：&arr：数组的首地址 sizeof(arr)
int arr[常量]; int *p = (int *)malloc(sizeof(int) * n);
### 题1：一个arr内有n个元素，每个元素值范围0~n-1之间 检测当前arr内是否有元素重复出现
1. 标记 arr{count， 标记}

	**时间复杂度：O(n)**

	**空间复杂度：O(n)**

	目标数组arr和标记数组count，遍历目标数组，判断每一个元素是否在标记数组出现过：

			1. 没出现过，标记值+1；
			1. 出现过，返回false；

2. Sort {比较（相邻数值，索引比较) 转换为字符串比较}

冒泡排序+数值和下标进行比较。

3. Value <--> Index 如果值与下标不一样则将这个数与下标位置的数交换



1. HashTable
2. Set/Map

# 链表List
- 链表是由一组不必相连【不必相连：可以连续也可以不连续】的内存结构 【节点】，按特定的顺序链接在一起的抽象数据类型。
> 补充：
抽象数据类型（Abstract Data Type [ADT]）：表示数学中抽象出来的一些操作的集合。
内存结构：内存中的结构，如：struct、特殊内存块...等等之类；
### 题1：反转链表 Reverse
1. 栈/双端队列
2. 头尾互换
3. 三个指针(第一个指针：反转后被指向的结点 第二个指针：反转后指向结点 第三个指针：反转后被断开的结点)
4. 头插法
5. 暴力
6. Array
### 题2：倒序打印
1.Reverse 遍历
2.Array
3.Stack
4.暴力
5.递归(1.判断终止 2.处理下一个 3.打印)
#### 递归Ree：函数调用自身实现的方法
1.可以将当前问题拆解成若干个除数据规模意外，实现方式完全相同的小问题。
2.有明确的终止条件

##### 题1：斐波那契数列
> F(n) = F(n-1) + F(n-2)

优化做法：三个变量，i-2，i-1，i辗转前移
##### 题2：青蛙跳台阶
> n级台阶：一次可以跳一级/两级
F(n) = F(n - 1) + F(n - 2) F(2) = 2 F(1) = 1 F(0) = 0
### 题3.链表合并：
1.Head Tail 2.比较 3.将剩余部分连接
### 题4.链表折叠：

#### [剑指 Offer II 026. 重排链表](https://leetcode.cn/problems/LGjMqU/)

1.拆开 2.倒置 3.合并

#### [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

1. 快慢指针：

	slow指针走一步，fast指针走两步，当fast指针走到链表尾，slow指针走到链表中间结点。

#### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

1. 三个指针：

	pre指针记录当前操作结点前一个结点。

	cur指针记录当前操作结点。

	next 指针记录cur的下一个结点。

	遍历条件：`while(next != NULL)`


### 判断链表是否有环，并找到入口结点

- 快慢指针：快指针(fast)和慢指针(slow),它们两个同时从链表头遍历链表，只不过**两者速度不同（可以快指针(fast)每次走两步，慢指针(slow)每次走一步）**，如果存在环那么最终会在循环链表中相遇。如果快指针先为null那就说明没环。

- 找到环入口：

	1. 快慢指针相遇的位置在环内。
	2. 慢指针走x步，快指针走2x步。
	3. 快指针走的步数=慢指针步数+n圈环长度 ==》 2x = x + ny ==》 x = ny
	4. 即慢指针走的步数是环长度的整数倍

	当快慢指针同时在环内同一点开始遍历，即相遇之后的再次相遇，一定在原点，因为慢指针走的步数是环的整数倍。

	**分别从头结点和快慢指针交汇点出发一个慢指针，它们依然到达快慢指针交汇点。当他们第一次相遇时，ji'we**

# 栈stack
- init() 初始化，创建空间
- push() 栈顶压入元素
- pop() 栈顶弹出元素
- top() 获取栈头元素
- clear() 清空栈
- destroy() 销毁top
- count() 计数 
- isempty() 空返回1

#### [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

- 方法

	1. 栈模拟

	```
	bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
	        stack<int> st;
	        int n = pushed.size();
	        for (int i = 0, j = 0; i < n; i ++) {
	            st.push(pushed[i]);
	            while(!st.empty() && j < popped.size() && popped[j] == st.top()) st.pop(), j ++;
	        }
	        return !st.size();
	    }
	```

	

### 中缀表达式
- 即，常规表达式
#### 中缀转后缀的规则 
1. 借助辅助栈 
2. 遇到数字或字母直接打印 
3. 遇到符号 拿当前符号与栈顶符号进行优先级比较 
- 如果当前符号优先级高则直接入栈 
- 如果当前符号优先级低则将栈内元素依次出栈直到比当前元素优先级低为止 再将当前符号入栈 
4. 遇到左括号无条件入栈 
5. 遇到右括号将栈内元素依次出栈直到左括号为止 左右括号消失 
6. 操作完成后将栈内所有元素弹出
> 简单方法：加括号(((3+2)*6)-(8/4))符号往括号外移3 2 + 6 * 8 4 / -

### 后缀表达式
#### 后缀转中缀的规则 
1. 借助辅助栈 
2. 遇到数字或字母直接入栈
3. 遇到符号将栈顶元素的下一个与栈顶元素构成表达式 

### 题1：单一括号完全匹配
1. 栈：只入栈左括号，遇到一个右括号就出栈一个左括号，如果出现右括号了但是栈内没有元素了就返回不匹配，如果全部输入完成栈内还有元素则不匹配
2. 动态计数 遇到左括号+ 遇到右括号- 如果出现负数就返回不匹配 如果最后数字不为0则不匹配
### 题2：{}\[]\()三种括号完全匹配
1. 栈：
- 左括号入栈 
- 遇到右括号与栈顶括号匹配 
- - 是则出栈
- - 不是则不匹配
# 队列queue
> 队列 先进先出 尾添加头弹出
init push pop front isempty

数组实现：添加 rear++ 弹出 front++
- 容易产生数组大小不够的情况 可以用循环队列 rear + 1 % n

链表实现：
- 尾填需要考虑当前链表是否为空 头删除

循环队列会产生假溢出问题

### 题1：约瑟夫环
N个人，编号是1~n，围成一圈，k从1号开始计数，数到第k个人，离开，再从第k+1的位置重新计数，数到第k个的人离开，最后圈中剩余的人，编号是多少？
1. 暴力 
2. 循环链表 
3. 队列 
(1)	队列：队列queue
(2)	入队push 计数器从0开始count
(3)	队内元素loop pop count++ k？ 否push 是 丢掉count=0
4. 数学映射

### 题2：两个栈实现队列的先进先出
维持一个栈是空栈 一个s1入一个s2出
Push:S2非空？
- 是：将s2->s1 新元素入s1 
- 否：新元素入s1

pop：s1非空？
- 是：s1->s2 s2.pop() 
- 否：s2.pop()
### 题3：两个队列实现栈的先进后出
Push：q1非空？
- 是：q1push 
- 否：q2push

Pop: 都空 
- 退出 

q1非空？
- 非空队列内元素 除尾以外 全部压入刀另外一个队列中 将队尾元素弹出

我们需要两个空队列，先将元素放入队列，然后再将非空队列的元素依次Pop放入空队列，直到非空队列的元素个数为1，（也就是如果非空队列中元素个数>1就一直Pop）此时再次进行Pop出的元素是我们所要的，然后又有一个空队列，和非空队列，如果在想取出元素就重复上述过程，但如果我们刚得到几个元素，又来了几个新的元素想要入队怎么办，我们要始终保证有一个队列是空的，所以新来的元素始终要入非空队列，然后让非空队列进行Pop，空队列Push,当然，第一次入队的时候就随机选择一个就可以了。

# 字符串String

一个**字符串**S是将n个字符顺序排列形成的序列，n称为S的长度，表示|S|。

**子串**：S[ i , j ] i <= j ， 表示S串中从i 到 j 这一段，形成的字符串。

**子序列**：从S 中将若干元素提取出来并不改变相对位置形成的序列。

**后缀** 是指从某个位置 开始到整个串末尾结束的一个特殊子串。

**前缀** 是指从串首开始到某个位置 结束的一个特殊子串。

**字典序**：以第 个字符作为第 关键字进行大小比较，空字符小于字符集内任何字符（即 a < aa）。

**回文串** 是正着写和倒着写相同的字符串。

**字符串的存储**：

- 使用 `char` 数组存储，用空字符 `\0` 表示字符串的结尾（C 风格字符串）。
- 使用 C++ 标准库提供的 [`string` 类](https://oi-wiki.org/lang/csl/string/)。

## 标准库

### **C标准库**：

**`char[]`/`const char*`**

- `printf("%s", s)`：用 `%s` 来输出一个字符串（字符数组）。
- `scanf("%s", &s)`：用 `%s` 来读入一个字符串（字符数组）。

- `sscanf(const char *__source, const char *__format, ...)`：从字符串 `__source` 里读取变量，比如 `sscanf(str,"%d",&a)`。
- `sprintf(char *__stream, const char *__format, ...)`：将 `__format` 字符串里的内容输出到 `__stream` 中，比如 `sprintf(str,"%d",i)`。
- `strlen(const char *str)`：返回从 `str[0]` 开始直到 `'\0'` 的字符数。注意，未开启 O2 优化时，该操作写在循环条件中复杂度是O(N)的。
- `strcmp(const char *str1, const char *str2)`：按照字典序比较 `str1 str2` 若 `str1` 字典序小返回负值，两者一样返回 `0`，`str1` 字典序更大则返回正值。请注意，不要简单的认为返回值只有 `0`、`1`、`-1` 三种，在不同平台下的返回值都遵循正负，但并非都是 `0`、`1`、`-1`。
- `strcpy(char *str, const char *src)`: 把 `src` 中的字符复制到 `str` 中，`str` `src` 均为字符数组头指针，返回值为 `str` 包含空终止符号 `'\0'`。
- `strncpy(char *str, const char *src, int cnt)`：复制至多 `cnt` 个字符到 `str` 中，若 `src` 终止而数量未达 `cnt` 则写入空字符到 `str` 直至写入总共 `cnt` 个字符。
- `strcat(char *str1, const char *str2)`: 将 `str2` 接到 `str1` 的结尾，用 `*str2` 替换 `str1` 末尾的 `'\0'` 返回 `str1`。
- `strstr(char *str1, const char *str2)`：若 `str2` 是 `str1` 的子串，则返回 `str2` 在 `str1` 的首次出现的地址；如果 `str2` 不是 `str1` 的子串，则返回 `NULL`。
- `strchr(const char *str, int c)`：找到在字符串 `str` 中第一次出现字符 `c` 的位置，并返回这个位置的地址。如果未找到该字符则返回 `NULL`。
- `strrchr(const char *str, char c)`：找到在字符串 `str` 中最后一次出现字符 `c` 的位置，并返回这个位置的地址。如果未找到该字符则返回 `NULL`。

### **C++标准库：**

**`std::string`**

- 重载了赋值运算符 `+`，当 `+` 两边是 `string/char/char[]/const char*` 类型时，可以将这两个变量连接，返回连接后的字符串（`string`）。
- 赋值运算符 `=` 右侧可以是 `const string/string/const char*/char*`。
- 访问运算符 `[cur]` 返回 `cur` 位置的引用。
- 访问函数 `data()/c_str()` 返回一个 `const char*` 指针，内容与该 `string` 相同。
- 容量函数 `size()` 返回字符串字符个数。
- `find(ch, start = 0)` 查找并返回从 `start` 开始的字符 `ch` 的位置；`rfind(ch)` 从末尾开始，查找并返回第一个找到的字符 `ch` 的位置（皆从 `0` 开始）（如果查找不到，返回 `-1`）。
- `substr(start, len)` 可以从字符串的 `start`（从 `0` 开始）截取一个长度为 `len` 的字符串（缺省 `len` 时代码截取到字符串末尾）。
- `append(s)` 将 `s` 添加到字符串末尾。
- `append(s, pos, n)` 将字符串 `s` 中，从 `pos` 开始的 `n` 个字符连接到当前字符串结尾。
- `replace(pos, n, s)` 删除从 `pos` 开始的 `n` 个字符，然后在 `pos` 处插入串 `s`。
- `erase(pos, n)` 删除从 `pos` 开始的 `n` 个字符。
- `insert(pos, s)` 在 `pos` 位置插入字符串 `s`。
- `std::string` 重载了比较逻辑运算符，复杂度是O(n) 的。

## 字符串匹配问题 - 模式匹配

> 给定字符串S和T，在主串S中寻找子串 T。字符T称为模式串 (pattern)。

**类型：**

- 单串匹配：给定一个模式串和一个待匹配串，找出前者在后者中的所有位置。
- 多串匹配：给定多个模式串和一个待匹配串，找出这些模式串在后者中的所有位置。
- 其他类型：例如匹配一个串的任意后缀，匹配多个串的任意后缀……

### 暴力做法

简称BF(Brute Force)算法。

1. 从主串S的第一个字符开始和模式串P的第一个字符开始比较。

  if 相等，继续比较二者的后续字符；

  else 不相等，模式串P回退到第一个字符，重新与主串S的第二个字符进行比较。

2. 重复以上步骤，直到S或P中所有字符比较完毕。

![img](https://www.ruanx.net/content/images/2020/02/3-1.png)

```cpp
/*
 * s：待匹配的主串
 * t：模式串
 * n：主串的长度
 * m：模式串的长度
 */
std::vector<int> match(char *s, char *t, int n, int m) {
  std::vector<int> ans;
  int i, j;
  for (i = 0; i < n - m + 1; i++) {
    for (j = 0; j < m; j++) {
      if (s[i + j] != t[j]) break; 
    }
    if (j == m) ans.push_back(i);
  }
  return ans;
}
```

设n为主串的长度， 为m模式串的长度。默认 m 远小于 n。

| 最好时间复杂度           | 最坏时间复杂度 | 平均时间复杂度 |      |
| ------------------------ | -------------- | -------------- | ---- |
| 匹配成功O(n)匹配失败O(m) | O(nm)          | O(n)           |      |

## KMP算法

- 暴力的改进思想---(**降低比较的趟数**)

> **尽可能利用残余的信息，是KMP算法的思想所在**。

1. next数组 (某个固定字符串的最长前缀和最长后缀相同的长度)

匹配串P的 next 数组定义为：next[i] 表示 P[0] ~ P[i] 这一个子串，使得 **前k个字符**恰等于**后k个字符** 的最大的k. 特别地，k不能取i+1（因为这个子串一共才 i+1 个字符，自己肯定与自己相等，就没有意义了）。
P="abcabd"时，next[4]=2，这是因为P[0] ~ P[4] 这个子串是"abcab"，前两个字符与后两个字符相等，因此next[4]取2.

2. 如何快速求next数组

	```cpp
	std::vector<int> buildNext(std::string& pattern) {
		std::vector<int> next(pattern.length(), 0);
	    for (int i = 0, j = 1; j < pattern.length(); j ++) {
	    	while (i > 0 && pattern[i] != pattern[j]) i = next[i - 1];
	    	if (pattern[i] == pattern[j]) i ++;
	    	next[j] = i;
	    }
	    return next;
	}
	```

3. 使用next数组进行匹配过程中的移动模式串

下图中的1，2，3，4是一样的。1-2之间的和3-4之间的也是一样的，我们发现A和B不一样；之前的算法是我把下面的字符串往前移动一个距离，重新从头开始比较，那必然存在很多重复的比较。现在的做法是，我把下面的字符串往前移动，使3和2对其，直接比较C和A是否一样。

![这里写图片描述](https://img-blog.csdn.net/20170207171916706?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3RhcnN0YXIxOTky/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**意思是，当发生失配，将模式串前移让next[失配前一个字符下标]+1这个位置的字符开始与主串失配位置进行重新匹配，重复上述操作直到S或P中所有字符比较完毕**

```cpp
// KMP
std::vector<int> buildNext(std::string& pattern) {
	std::vector<int> next(pattern.length(), 0);
    for (int i = 0, j = 1; j < pattern.length(); j ++) {
        while (i > 0 && pattern[i] != pattern[j]) i = next[i - 1]; // 回溯
        if (pattern[i] == pattern[j]) i ++;
        next[j] = i;
    }
    return next;
}
int strStr(string haystack, string needle) {
	vector<int> next = buildNext(needle); // 求next数组
    for (int i = 0, j = 0; i < haystack.length(); i ++) {
    	while (j > 0 && haystack[i] != needle[j]) j = next[j - 1]; // 回溯
        if (haystack[i] == needle[j]) j ++;
        if (j == needle.length()) return i - j + 1;
    }
    return -1;
}
```

## Sunday算法

Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。

- 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1；
- 否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。

```cpp
int strStr(string match, string pattern) {
    unordered_map<char, int> shift; // 偏移表
    for (int i = 0; i < pattern.length(); i ++) {
        shift[pattern[i]] =  pattern.length() - i;
    }
    for (int i = 0, j = 0; i < match.length()- pattern.length() + 1;) {
        for (j = 0; j < pattern.length(); ++ j) {
            if (match[i + j] != pattern[j]) {
                if (shift.find(match[i + pattern.length()]) != shift.end())
                    i += shift[match[i + pattern.length()]];
                else i += pattern.length() + 1;
                break;
            }
        }
        if (j == pattern.length()) return i;
    }
    return -1;
}
```



## 字符串哈希

> 定义一个把字符串映射到整数的函数f，这个f称为hash函数。这个函数f可以方便地帮我们判断两个字符串是否相等。
>
> hash的核心思想在于，将输入映射到一个值域较小，可以方便比较的范围。

**字符串哈希的性质：**

1. 在hash函数值不一样时，两个字符串一定不一样。

	2) 在hash函数值一样时，两个字符串不一定一样(大概率一样，且我们希望它们总是一样的)

  hash函数值一样时原字符串不一样的现象称为**哈希碰撞**

通常我们采用多项式哈希的方法，对于一个长度为l的字符串s来说，定义多项式哈希函数：

$$
f(s) = \sum_{i=1}^ls[i]{\times}b^{l-i}(mod\ M)
$$

例如，对于字符串xyz，其哈希函数值为
$$
f(xyz) = x{\times}b^2 + y{\times}b + z (mod\ M)
$$

通过这种哈希方法，可以把字符串的每一个字符根据ASCII码值映射成一个b进制数（**不能映射成0**,否则会出现不同字符都映射成0的情况，比如A，AA，AAA皆为0）

**如何选择M和计算哈希碰撞的概率：**

通常来说： M需要选择一个素数（至少要比最大的字符要大）， b可以任意选择。

> 经验：b = 131 或13331
>
> M = 2^64 (unsigned long long)， 设置成这样的值一般可以理解为不会产生哈希冲突

```C++
const int B = 131;
typedef unsigned long long ULL;
int get_hash(string s) {
    int res = 0;
    for (int i = 0; i < s.size(); i ++) {
        res = unsigned long long(res * B + s[i]);
    }
}
```

### 字符串前缀哈希法

> **前缀哈希可以求出任意子串的哈希值**

**单次计算一个字符串的哈希值的时间复杂度是O(n)的，n为字符串长度,这与暴力匹配没有什么区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率非常低下。**

一般采取的方法是对整个字符串先预处理出每个前缀的哈希值，将哈希值看成一个b 进制的数对M 取模的结果，这样的话每次就能快速求出子串的哈希了：

令f<sub>i</sub>(s) 表示 f(s[1……i])， 即原串的长度为i的前缀的哈希值，那么按照定义有
$$
f_i(s) = s[1]{\times}b^{i-1} + s[2]{\times}b^{i-2} + ……+s[i-1]{\times}b + s[i]
$$

现在，用类似前缀和的方法快速求出f(s[l, r]), 按照定义有字符串s[l, r] 的哈希值为
$$
f(s[l, r]) = s[l]{\times}b^{r-l} + s[l+1]{\times}b^{r-l-1} + …… + s[r-1]{\times}b + s[r]
$$

**对比上述两个式子，f（s[l , r] ) = f<sub>r</sub>(s) - f<sub>l-1</sub>(s) x b<sup>r-l+1</sup>**

> 求一个字符串的哈希值就相当于求前缀和，求一个字符串的子串的哈希值就相当于求部分和
>区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，
> 乘上 P2P2 把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。

**故：字符串哈希的公式可化为：**
$$
f(i) = f(i-1){\times}b + s[i]
$$

```C++
const int B = 131;
const int N = 1e5 + 10;
typedef unsigned long long ULL;
ULL f[N]; // 记录字符串长度为i的前缀的哈希
ULL b[N]; // 记录b的i次方
void deal_str(string s) { // 处理原串
    int res = 0;
    b[0] = 1; // b^0 = 1; 
    for (int i = 1; i < s.size(); i ++) {
        b[i] = b[i-1] * B;
        f[i] = f[i-1] * B + s[i];
    }
}
ULL get (int l, int r) { // 计算子串 str[l~r]的哈希值
	return f[r] - f[l] * p[r-l+1];
}
```

<img src="C:\Users\28568\AppData\Roaming\Typora\typora-user-images\image-20221106185232396.png" alt="image-20221106185232396" style="zoom: 50%;" />

字符串哈希的应用：1. 字符串匹配 2.允许k次失配的字符串匹配(这道题无法用kmp解决，但是可以通过哈希+二分来解决) 3. 最长回文子串

## 字典树Trie

字典树（Trie）是一种高效的存储和查找字符串集合的数据结构。如同其名，它的构成就像一本字典。**核心思想是空间换时间**

**字典树的性质**

1. 根节点（Root）不包含字符，除根节点外的每一个节点都仅包含一个字符；
2. 从根节点到某一节点路径上所经过的字符连接起来，即为该节点对应的字符串；
3. 任意节点的所有子节点所包含的字符都不相同；

**代码实现可以用二维数组模拟**

**Trie 关键词查找过程：**

1. 每次从根结点开始搜索；

2. 获取目标字符串的第一个字符, 根据该字符找到对应的子节点

	- 如果子节点存在，获取目标字符串的下一个字符转到该子节点进行搜索重复刚才操作进行迭代。
	- 如果子节点不存在，说明该字符串不在该字典树中。结束判断。

3. 当目标字符串在某个节点处，其所有字符都被取出，则读取该节点上的信息(即该节点是否为字符串的结尾)，查找完成。

	```
	int query(char str[]) {
	    int p = 0; 
	    for (int i = 0; str[i]; i ++) {
	        int u = str[i] - 'a';
	        if(!son[p][u]) return 0;
	        p = son[p][u];
	    }
	    return cnt[p];
	
	```

**Trie插入过程：**

1. 子节点存在。沿着指针移动到子节点，继续处理下一个字符。
2. 子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。
3. 重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。

```C++
const int N = 1e5 + 10;
int son[N][25]; // （某一点的横坐标表示子节点在数组的哪一行，纵坐标表示当前点代表的字符）假设字符串全是小写字母或大写字母，每一个节点对应的子节点最多有26个。
char str[N]; // 目标字符串
int cnt[N]; // 记录以当前节点结尾的字符串一共有多少个
int idx; // 当前所用到的节点数
void insert(char str[]) { // 插入字符串
    int p = 0; // 从根节点开始插入
    for (int i = 0; str[i]; i ++) { // 遍历目标字符串
        int u = str[i] - 'a'; // 当前字符对应的数字
        if(!son[p][u]) { // 如果当前节点没有u这个子节点，创建一个新的子节点，记录在children数组的对应位置上
            son[p][u] = ++ idx; // 创建当前节点的u这个子节点，值为当前以使用到的节点数+1;
        }
        p = son[p][u]; // 移动指针到该子节点，继续遍历下一个字符
    }
    cnt[p] ++; // p是字符串最后一个字符对应的idx
}
```



# 哈希表
> 对无序数据的快速搜索
> 适合于反复搜索

> 常常需要用到设置一个常量用来代表“无穷大”。
>
> 比如对于int类型的数，有的人会采用INT_MAX，即0x7fffffff作为无穷大。但是以INT_MAX为无穷大常常面临一个问题，即加一个其他的数会溢出。
>
> 而这种情况在动态规划，或者其他一些递推的算法中常常出现，很有可能导致算法出问题。
>
> 所以我们常采用0x3f3f3f3f来作为无穷大。0x3f3f3f3f主要有如下好处：
>
> 0x3f3f3f3f的十进制为1061109567，和INT_MAX一个数量级，即10^9数量级，而一般场合下的数据都是小于10^9的。
> 0x3f3f3f3f * 2 = 2122219134，无穷大相加依然不会溢出。
> 可以使用memset(array, 0x3f, sizeof(array))来为数组设初值为0x3f3f3f3f，因为这个数的每个字节都是0x3f。
>
> **memset按字节初始化。**

1、按什么规则散列
(1)	确定散列函数 求整取余 p=key%m （**一般m要取成一个质数，尽可能远离2的整数次幂**）
(2)	确定处理哈希冲突的办法（一般拉链法）
①	开放地址法 （**如果看到一个坑里有人就往前找没人的坑**）

- 1. 线性探测

		> 对线性探测的优化
		> 优化 = 个数/表数 = a(装载因子)
		> a > 0.8 => 容易发送冲突
		> a > 0.8 => 发送冲突的可能性变小

- 2)	二次探测

②	拉链法（**认准一个坑无论有没有人都在厕所门口排队**）

1. 拉链法

- 插入：

	```C++
	void insert(int x) {
	    int k = (x % N + N) % N;
	    e[idx] = x;
	    ne[idx] = h[k];
	    h[k] = idx ++;
	}
	```

- 查询：

	```C++
	bool query(int x) {
	    int k = (x % N + N) % N;
	    for (int i = h[k]; i != -1; i = ne[i]) 
	        if(e[i] == x) return true;
	        
	    return false;
	}
	```

2. 开放地址法

	- 找存储索引：

		```c++
		int find(int x) {
		    int k = (x % N + N) % N;
		    while(h[k] != null && h[k] != x) {
		        k ++;
		        if(k == N) k = 0;
		    }
		    return k;
		}
		```

# 并查集

> 1. 将两个集合合并 （近乎O(1)）
> 2. 询问两个元素是否出现在一个集合中

基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父结点，p[x] 表示x的父结点

问题1：如何判断是不是树根 **if（p[x] == x)**

问题2：如何求x的集合编号：while(p[x] != x) x = p[x];

问题3：如何合并两个集合  p[x] 是 x 的集合编号，p[y] 是 y 的集合编号， p[x] = y

**优化:(1)路径压缩**

```c++
int find(int x) { // 找到x的祖宗节点 + 路径压缩
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}
```

# 堆

如何手写一个堆？

结构是一个完全二叉树，

小根堆的性质：左右孩子大于等于父结点， 根是最小值。

堆的存储：以一维数组为例

| 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- |

1为根节点，x的左儿子在2x，x的右儿子在2x+1

支持的操作：

1. 插入一个数	heap[++size] == x up(x)
2. 求集合中的最小值  heap[1]
3. 删除最小值  head[1] = heap[size]; size--; down(1);
4. 删除任意一个元素 heap[k] = heap[size]; size--; down(k) || up(k);
5. 修改任意一个元素 heap[k] = x; down(k) || up(k);

堆的基本操作：

down(x): 往下调整

up(x):往上调整 

##### 如何建堆？

1. 可以一个一个往heap里面插，n步操作每步操作的时间复杂度是O(logN) , 所以是NlogN.
2. **从n/2开始down ， O(n)操作**

# 跳跃列表Skip List

> 跳表全称叫做跳跃表，简称跳表。跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。

- 查找和插入的时间复杂度都只有O(logN)

### 1. 创建

1. 头结点为哨兵Sentinel 抛硬币决定每个节点是否升一层,Sentinel总是会长高一层。

2. 然后再在升一层的节点继续抛硬币决定是否升

3. 层数由用户自己决定，最好是logn 层 0层开始

### 2. 查找

1. 查找的时候从高层开始 然后向下层寻找

### 3. 插入

1. 查询插入位置，与Skip List查询方法一致，在L0层找到第一个比插入结点大的结点位置
2. 查找过程中记录路径，插入元素应该落在每一层的哪两个结点之间，用一个数组记录每一层的路径start from
3. 构建新的结点，插入到跳跃列表的第L0层，该结点高度随机，一开始是0，通过抛硬币确定该结点的高度，直到抛到反面为止。
4. 用start from表中的记录将新的结点与跳跃列表中的结点每一层连接起来

# 分治法

1.问题难度随着数据规模缩小而降低 2.问题可分 3.子问题的解可合并 4.子问题之间相互独立

# 二分查找

二分搜索（binary search），也称折半搜索（half-interval search），是一种在**有序数组**中查找某一特定元素的搜索算法。

搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

- 不需要考虑边界的解法

```C++
int l = -1, r = n; // 定义两个指针
while(l + 1 != r) {
	int mid = l + r >> 1;
    if (check(mid)) l = mid;
    else r = mid;
}
```

链接：[(31条消息) 不需要考虑mid+1、mid-1的二分查找模板，希望大家都能学会_WJPnb1的博客-CSDN博客](https://blog.csdn.net/WJPnb1/article/details/126360962?spm=1001.2014.3001.5502)

# 快速幂

- **递归版本**

	当我们要计算x<sup>n</sup>时，我们可以先递归地计算出y = x<sup>[n/2]</sup>,其中[a] 表示对 a 进行向下取整

	根据递归的计算结果，如果n为偶数，那么x<sup>n</sup> = y<sup>2</sup>; 如果n为奇数，那么x<sup>n</sup> = y<sup>2</sup> X x;

	递归的边界是n = 0， 任意数的0次方均为1.

	```C++
	double quickMul(double x, long long N) {
	        if (N == 0) return 1.0;
	        
	        double y = quickMul(x, N / 2);
	        return N % 2 == 0 ? y * y : y * y * x;
	    }
	
	```

	

# 树
一对多结构 树 Tree 根root结点 叶子结点 中间结点 层数
路径长度：边的数目
度：结点的孩子个数

BinaryTree 二叉树 只允许有两个孩子
满二叉树  完全二叉树（只允许最后一层有空缺并且其空缺方式从右向左连续空缺）
排序二叉树/二叉搜索树BST 左小于父亲 右大于父亲
二叉平衡搜索树AVL 树中左右子树高度差不超过1
红黑树RBT

性质：（k层）
1、最多有2^k-1个结点
2、叶子结点最多有2^（k-1）
3、任何一个二叉树中度为0的结点总比度为2的结点多一个
4、将一棵完全二叉树从上到下，从左至右的顺序从1开始编号，编号为i的结点如果满足2i<=n则该结点有左孩子，编号为2i，如果满足2i+1<=n，则该结点有右孩子，编号为2i+1， 父亲结点的编号范围为1~n/2。如果从0开始编号，i；2i+1；2i+2 ；父亲范围为0~n/2-1。
5、 k = [log2^n] + 1

### 遍历
前序遍历：根左右
中序遍历：左根右
后序遍历：左右根

完全二叉树和满二叉树可以用顺序存储

创建完全二叉树
1、申请空间
2、拷贝数据copy
3、Left right 首元素地址就是根节点地址

### 层序遍历
队列
1、辅助队列queue
2、Root入队
3、队列内元素弹出 打印 将非空的孩子放入队列等待处理（循环，队列为空结束循环）

### 题1：二叉树按层打印



标记：实现按层打印，定义变量curLevelSize 记录当前 队列大小， 在pop队首元素时弹出curLevelSize那么多队首，即为一层

方法：

1、计数
2、计算每个结点的深度
3、二维数组
4、完全二叉树
5、标记

- (1)	1标+队尾（结点）
- (2)	2标（结点）
- (3)	1标入队（结点分隔两层）

6、双队列

### 非递归的前序遍历
1、申请辅助栈
2、遍历 非空print push保存 找left  空: Pop 找right    循环
### 非递归后序遍历
1、辅助栈
2、遍历 
- (1)	非空 push保存
- (2)	 找left 
- (3)	检测top的right 
- - ①无/处理完：pop print 标记mark
- - ②处理右侧

#### 判断是否是BST的后序遍历序列

根据后序遍历的定义，确定后序遍历序列的最后一个节点是根节点，根据BST的定义，从左到右找到第一个大于根节点的节点。进行判断：

 1. 如果找到的该节点为根节点，说明右子树为空，接下来只需要递归的判断左子树是否为BST

 2. 如果该节点是序列第一个元素**且该节点往后的每一个节点都大于根节点**，说明左子树为空，那么只需要判断右子树是否为BST

 3. 存在左右子树，验证该节点右边的节点是否每个都大于根节点，若不符合直接返回false，递归判断左右子树是否为BST

	```C++
	bool isBST(int arr[], int begin, int end) {
	    if (arr == NULL) return false;
	    if (begin <= end) return true;
	    int root = arr[end];
	    int i = begin;
	    // 查找到第一个大于root节点的节点
	    while (arr[i] < root && i < end) i ++;
	    if (i == end) { // 找到的该节点为根节点，说明右子树为空，接下来只需要递归的判断左子树是否为BST
	        isBST(arr,  begin, end - 1);
	    } else if (i == begin) { //该节点是序列第一个元素且该节点往后的每一个节点都大于根节点，说明左子树为空，那么只需要判断右子树是否为BST
	        int tmp = i;
	        while(tmp < end) {
	            if (arr[tmp] <= arr[end]) return false;
	            tmp ++;
	        }
	        isBST(arr, i, end - 1);
	    } else { //递归判断左右子树是否为BST
	        int tmp = i;
	        while(tmp < end) {
	            if (arr[tmp] <= arr[end]) return false;
	            tmp ++;
	        }
	        return isBST(arr, begin, i-1) && isBST(arr, i, end-1);
	  	}
	    return false;
	}
	```


#### 根据（前序，中序）或（中序，后序）构造二叉树

- 中序和后序遍历：

1. 首先找到后序遍历的最后一项，此为这棵二叉树的根节点，赋值给二叉树的根节点；
2. 由于序列中没有重复元素，在中序遍历中找到根节点位置，从此位置向左为左子树，向右为右子树；
3. 后序遍历去掉最后一项后也分为左子树和右子树，根据之前在中序遍历序列中得到的左右子树长度，将后序遍历也分割为左右子树；
4. 将中序左子树与后序左子树作为参数继续这一过程，右子树同理。

```C++
TreeNode* buildTree(int inbegin, int inend, int postbegin, int postend) {
    if (postbegin > postend || inbegin > inend) return NULL;
    int root = postorder[postend];
    TreeNode* head = (TreeNode*)malloc(sizeof(TreeNode));
    head->value = root;
    int i = inbegin;
    while(inorder[i] != root) i ++;
    int lchildNum = i - inbegin;
    head->left = buildTree(inbegin, i-1, postbegin, postbegin + lchildNum - 1); // 递归处理左子树
    head->right = buildTree(i + 1, inend, postbegin + lchildNum, postend - 1); // 递归处理右子树

    return head;
}
```

- 根据前序和中序：（根左右）（左右根）[3, 9, 20, 15, 7] [9, 3, 15, 20, 7]

	1. 先找到前序遍历的第一项，此为这棵二叉树的根节点，赋值给二叉树的根节点；
	2. 由于序列中没有重复元素，在中序遍历中找到根节点位置，从此位置向左为左子树，向右为右子树；
	3. 前序遍历去掉第一项后也分为左子树和右子树，根据之前在中序遍历序列中得到的左右子树长度，将后序遍历也分割为左右子树；
	4. 将前序左子树与中序左子树作为参数继续这一过程，右子树同理

	```
	class Solution {
	public:
	    TreeNode* dfs(vector<int>& preorder, vector<int>& inorder, int prebegin, int preend, int inbegin, int inend) {
	        if (prebegin > preend || inbegin > inend) return NULL;
	        int root = preorder[prebegin];
	        TreeNode* head = (TreeNode*)malloc(sizeof(TreeNode));
	        head->val = root;
	        int i = inbegin;
	        while(inorder[i] != root) i ++;
	        int lchildNum = i - inbegin;
	        head->left = dfs(preorder, inorder, prebegin + 1, preend + lchildNum, inbegin, i-1); // 递归处理左子树
	        head->right = dfs(preorder, inorder, prebegin + 1 + lchildNum, preend, i + 1, inend); // 递归处理右子树
	
	        return head;
	    }
	    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
	        TreeNode* root = dfs(preorder, inorder, 0, preorder.size()-1, 0, inorder.size()-1);
	        return root;
	    }
	};
	```

	

### BST排序二叉树

- 概念：
	1. 任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
	2. 任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
	3. 任意节点的左、右子树也分别为二叉查找树；
	4. 没有键值相等的节点。

- 节点数据结构

	```C++
	typedef struct Node
	{
	    int val;
	    struct Node* left;
	    struct Node* right;
	}BSTree;
	```

- BST添加 --- 给定一个序列
	1、空树 添加为根
	2、非空 比较 当前值＞当前结点 看右侧 非空继续比较 空 放入 ；当前值＜当前结点 看左侧

- BST删除

	1、search 找到对应值的位置
	2、Delete 
	(1)	0个孩子直接删除 赋空值
	(2)	1 爷爷和孙子相连
	(3)	2 找左子树最大或右最小 替换 删除掉右子树最小的/左子树最大的 

#### BST操作——让两边数据平衡 旋转

> 为了保证BST的平衡(不会退化成为一条链)，通常通过旋转操作来改变BST的结构。旋转操作不会影响BST的性质！


- 左的左引起的不平衡要右旋 
	1、旋转参数 要转的点
	2、三个孩子 三个父亲 

- 由右的右引起的不平衡要左旋

	```C++
	void Right(Tree*& root, Tree* cur) {
	    if(cur == nullptr || cur->lchild == nullptr) return;
	
	    Tree* temp = cur->lchild;
	    // 三个孩子.cur ,cur->left, cur->parent
	    cur->lchild = temp->rchild; // 被旋转结点成为左孩子的右孩子
	    temp->rchild = cur; // 被旋转结点的左孩子的右孩子成为旋转结点
	    if(cur->parent != nullptr) {
	        // 判断cur是parent结点的左孩子还是右孩子
	        if(cur->parent->lchild == cur) cur->parent->lchild = temp;
	        else cur->parent->rchild = temp;
	    } else {
	        root = temp;
	    }
	    // 三个父亲
	    if(cur->lchild != nullptr) cur->lchild->parent = cur; // 判断原被旋转结点的左孩子的右孩子是否存在
	    temp->parent = cur->parent;
	    cur->parent = temp;
	}
	```

	

### 红黑树

#### 八股文：

**1 STL中的set底层用的什么数据结构？**

红黑树(Map也是)

**2 红黑树有哪些性质？**

1. 具有二叉查找树的特点
2. 根节点是黑色的；
3. 每个叶子节点都是黑色的空节点（NIL）
4. 父子节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的
5. 每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点

**3 红黑树的各种操作的时间复杂度是多少？**

能保证在最坏情况下，基本的动态几何操作的时间均为O(logN)

**4 红黑树相比于BST和AVL树有什么优点？**

相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。

红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多。

avl树是严格的平衡树，而红黑树没那么严格，因此avl树在搜索上略胜红黑树。也因为太严了，删除操作avl树性能比红黑树差。

**5 红黑树相对于哈希表，在选择使用的时候有什么依据？**

红黑树是有序的，Hash是无序的，根据需求来选择。

红黑树占用的内存更小（仅需要为其存在的节点分配内存），而Hash事先就应该分配足够的内存存储散列表（即使有些槽可能遭弃用）。

红黑树查找和删除的时间复杂度都是O(logN)，Hash查找和删除的时间复杂度都是O(1。

#### 性质：
1、红黑树中每个结点要么是红要么是黑
2、根结点必须是黑色的
3、终端结点被认为是黑色的 黑哨兵
4、不允许两个红结点互为父子关系
5、从任意结点向下出发，到其所有能到达的各个终端结点的各条路径上，黑结点的数目必须完全相同 红黑树上不会有一条路径的长度超过其他路径的两倍
增删查时间消耗都是log2 n

#### 红黑树的添加 
前提：search放入   操作结点z
1、空树 z变黑 为新根 结束
2、非空树
(1)	父亲是黑色 z放入 结束
(2)	父亲是红色 
①	叔叔红 父变黑 叔变黑 爷变红 爷为新z 重新讨论
②	叔叔黑
1)	父是爷的左
a.	z是父的右 父为新z，以z为旋转点左旋
b.	z是父的左 父变黑 爷变红 以爷为旋转点右旋 结束
2)	父是爷的右
a.	z是父的左 父为新z，以z为旋转点右旋
b.	z是父的右 父变黑 爷变红 以爷为旋转点左旋 结 

#### 红黑树的删除
1、查找
2、孩子情况的处理
3、删除 进行颜色讨论
(1)	z根且无子 删z 结束
(2)	z根有子 红子变黑 成为新根 删z 结束
(3)	z是红 删z 结束
(4)	z是黑 非根 有子 红子变黑与爷连接 删z 结束
(5)	z黑 非根 无子
①	兄是红 父变红 兄变黑 以父为旋转点旋转
②	兄黑
1)	两侄全黑
a.	父红 父变黑 兄变红 结束
b.	父黑 兄变红 父为新z 重新讨论 
2)	左侄红 右侄黑
a.	兄是父左侧 父色给兄 父变黑 左侄变黑 以父为旋转点右旋
b.	兄是父右 兄变红 左侄变黑 以兄为旋转点右旋
3)	右侄红
a.	兄是父左 兄变红 右侄变黑 以兄弟为旋转点左旋
b.	兄是父右 父色给兄 父变黑 右侄变黑 以父为旋转点左旋 结束 
### B-Tree

B树和平衡二叉树的不同之处是：B树属于多叉树又名平衡多路查找树（查找路径不止两个），数据库索引技术里大量使用着B树和B+树的数据结构。

（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；

（2）子节点数：非叶节点（根节点和枝节点）的子节点数 >1、且子节点数量<=M 、且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；

（3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);

（4）所有叶子节点均在同一层、叶子节点除了包含了关键字 和 关键字记录的指针外，也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

B树又称为多路查找树，是一种组织和维护外存文件系统非常有效的数据结构

一个m阶B树或者是一棵空树，或者是满足要求的m叉树：
1. 树中每个节点至多有m个孩子结点(即至多有m-1个关键字)
2. 除根节点外，其他非叶子结点至少有[m/2]个孩子结点(即至少有[m/2]-1个关键字)
3. 若根结点不是叶子结点，则根结点至少有两个孩子结点
4. 每个结点中的关键字按大小顺序排列
5. 所有外部结点都在同一层上。B树是所有结点的平衡因子均等于0的多路查找树

##### 在某个叶子结点插入关键字分两种情况
1. 插入结点有空位置，即关键字个数n < m-1 : 直接把关键字k有序插入到该结点的合适位置上
2. 插入结点没有空位置，即原关键字个数n = m-1 ==> 分裂
    - 如果没有父结点，新建一个父结点，树的高度增加一层
    - 如果有父结点，将插入k后中间位置的关键字ki插入到父结点上


### B+树 M阶M叉
叶子结点：记录存在于叶子结点中
索引结点：只包含索引
相邻的叶子结点之间有指针指向
根结点可以是叶子结点也可以是索引结点，关键字最少有一个
#### 在某个叶子结点插入关键字
1. 空树：新纪录添加到叶子结点中，当前结点既是根也是叶子结点
2. 非空树：找到合适叶子结点，将记录放入讨论当前结点关键字个数
    - 关键字个数 <= m-1，结束
    - 关键字个数 > m-1，裂变，左侧结点持有ceil(m/2)-1个关键字，右侧结点持有剩余记录，第ceil(m/2)个记录的关键字添加到父结点。
3. 讨论父结点关键字个数
    -  <= m-1, 结束
    -  /> m-1, 中间关键字上移，左右裂变，重复3
#### 删除记录
1. 叶子结点关键字个数 >= ceil(m/2)-1，结束
2. 叶子结点关键字个数 < ceil(m/2),看兄弟结点关键字个数
3. 兄弟结点关键字个数 > ceil(m/2)-1，从兄弟结点借一个记录过来，同时进行父亲结点对应关键字替换
4. 兄弟结点关键字个数 <= ceil(m/2)-1, 合并兄弟和给当前结点，删除父亲结点对应索引
5. 讨论父亲结点关键字个数
6. 父亲结点关键字个数 >= ceil(m/2)-1，结束
7. 父亲结点关键字个数 < ceil(m/2),看父亲兄弟结点关键字个数
8. 父亲兄弟结点关键字个数 > ceil(m/2)-1，兄弟结点拿一个关键字上移至父亲结点，父亲结点下移对应的关键字到当前结点
9. 父亲兄弟结点关键字个数 <= ceil(m/2)-1，父亲结点下移一个关键字，与当前结点和兄弟结点合并成一个新结点，重复5

**区别：**

**1.（结构区别）B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。**

**2（搜索区别）. B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B树每个节点 key 和 data 在一起，则无法区间查找。**

**3.B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确**

4.增删区别：上面

### 哈夫曼树
哈夫曼编码，用来实现无损压缩和恢复的
路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。

路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。

结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。

结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。

树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。

# 图
多对多
- 节点(Vertex) 与 边（Edge）
G=（V,E）

有向完全图中 边有An2  n（n-1）
> 图是一种复杂的非线性结构。
在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继；
在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素(parent node)及下一层的多个元素(孩子节点)相关；
而在图形结构中，节点之间的关系是任意的，图中任意两个数据元
素之间都有可能相关。


#### 图的表示： 邻接表 和 邻接矩阵
- 邻接矩阵:原理就是用二维数组，坐标保存顶点集，坐标对应的值保存边集。
- 邻接表：邻接表是图的一种链式存储结构。这种存储结构类似于树的孩子链表。对于图G中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的邻接表。

这里可以分为 
1. 有向图 和 无向图
无向图是一种特殊的有向图
2. 有权图 和 无权图

#### DFS

深度优先搜索在搜索过程中访问某个顶点后，需要递归地访问此顶点的所有未访问过的相邻顶点。因为对图中每个结点只遍历一次，所以需要一个标记数组来标记当前结点是否被遍历。对相邻顶点处理的办法与当前结点相同。



任意一个结点出发，遍历到任意一个与他相关联的未被处理过的结点
1、申请标记数组 赋0
2、进行遍历 打印 标记 检测相关点
(1)	遍历当前点的其他相关边，找到有关且未处理（处理2）loop

#### BFS

广度优先遍历，1. 首先起始节点压入队列2. 弹出队头元素，打印，将队头元素的相邻且未被访问过节点压入队列

重复这个步骤，直到队列为空。

1、标记数组
2、队列queue
3、遍历 
(1)	起始顶点入队 标记
(2)	遍历
①	队头元素打印，弹出
②	相关顶点未处理的 保存 标记 重复2


#### Dijkstra

> 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。
> 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。

有向的带正权值的图中，点与点之间的最短距离

S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。

- 操作步骤：
1. 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。
2. 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。
3. 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。
4. 重复步骤(2)和(3)，直到遍历完所有顶点。

### 最小生成树
#### Kruskal算法
> 适合于求边稀疏的网的最小生成树。
将所有边按照权值的大小进行升序排序，然后从小到大一一判断，条件为：如果这个边不会与之前选择的所有边组成回路，就可以作为最小生成树的一部分；反之，舍去。直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。筛选出来的边和所有的顶点构成此连通网的最小生成树。

>判断是否会产生回路的方法为：在初始状态下给每个顶点赋予不同的标记，对于遍历过程的每条边，其都有两个顶点，判断这两个顶点的标记是否一致，如果一致，说明它们本身就处在一棵树中，如果继续连接就会产生回路；如果不一致，说明它们之间还没有任何关系，可以连接。



#### Prim算法
> 点 边的权值（先选点，再找边的权值最小的，从所有已选点的相连边中找最小的，重复操作）

普里姆算法在找最小生成树时，将顶点分为两类，一类是在查找的过程中已经包含在树中的（假设为 A 类），剩下的是另一类（假设为 B 类）。

对于给定的连通网，起始状态全部顶点都归为 B 类。在找最小生成树时，选定任意一个顶点作为起始点，并将之从 B 类移至 A 类；然后找出 B 类中到 A 类中的顶点之间权值最小的顶点，将之从 B 类移至 A 类，如此重复，直到 B 类中没有顶点为止。所走过的顶点和边就是该连通图的最小生成树。

```C++
int minKey(int key[], bool mstSet[])
{
    // Initialize min value
    int min = INT_MAX, min_index;
 
    for (int v = 0; v < V; v++)
        if (mstSet[v] == false && key[v] < min)
            min = key[v], min_index = v;
 
    return min_index;
}

void printMST(int parent[], int graph[V][V])
{
    cout << "Edge \tWeight\n";
    for (int i = 1; i < V; i++)
        cout << parent[i] << " - " << i << " \t"
             << graph[i][parent[i]] << " \n";
}

void primMST(int graph[V][V])
{
    // parent 数组用于记录最小生成树中各个顶点父节点的位置，便于最终生成最小生成树
    int parent[V];
 
    // Key values used to pick minimum weight edge in cut
    int key[V];
 
    // To represent set of vertices included in MST
    bool mstSet[V];
 
    // Initialize all keys as INFINITE
    for (int i = 0; i < V; i++)
        key[i] = INT_MAX, mstSet[i] = false;

    key[0] = 0;
    parent[0] = -1; // First node is always root of MST
 
    // The MST will have V vertices
    for (int count = 0; count < V - 1; count++) {
        int u = minKey(key, mstSet);
        mstSet[u] = true;
        for (int v = 0; v < V; v++)
            if (graph[u][v] && mstSet[v] == false&& graph[u][v] < key[v])
                parent[v] = u, key[v] = graph[u][v];
    }
    printMST(parent, graph);
}
```



### 拓扑排序（找入度为0的点）

1. 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。

2. 从图中删除该顶点和所有以它为起点的有向边。

3. 重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。

	**拓扑排序通常用来“排序”具有依赖关系的任务。**确定一个依赖关系集中，事物发生的顺序

拓扑排序的实现算法有两种：入度表、DFS，其时间复杂度均为O(V+E)。
#### 入度表+queue
1. 找出图中0入度的顶点；

2. 依次在图中删除这些顶点，删除后再找出0入度的顶点；

3. 然后再删除……再找出……

4. 直至删除所有顶点，即完成拓扑排序

	```C++
	bool Graph::topological_sort() {
	    for (int i = 0; i < v; i ++) {
	        if(indegree[i] == 0) { // 入度为0的点
	            q.push(i);
	        }
	    }
	    int count = 0; // 计数， 记录当前已经输出的顶点数
	    while(!q.empty()) {
	        int v = q.front();
	        q.pop();
	        cout << v << " ";
	        ++count;
	        auto beg = adj[v].begin();
	        while(beg != adj[v].end()) {
	            if(!(--indegree[*beg])) q.push(*beg);
	            beg++;
	        }
	    }
	    if (count < v) return false;
	    else return true;
	
	```
#### DFS
找到一个入度为0的点，对其进行dfs，回溯时的顺序就是就是拓扑排序的逆序。

在拓扑排序中，我们使用临时堆栈。我们不会立即打印顶点，我们首先以递归方式调用所有相邻顶点的拓扑排序，然后将其推送到堆栈。最后，打印堆栈的内容。请注意，仅当顶点的所有相邻顶点（及其相邻顶点等）已在堆栈中时，才会将顶点推送到堆栈。

![拓扑排序](https://media.geeksforgeeks.org/wp-content/uploads/20200818211917/Topological-Sorting-1.png)

- 有以下几个要注意的点：
每次访问的结点必须入度为零	
不能出现回退边（访问到一个在前边的递归过程中没有处理完的点），出现回退边意味着这个图不是一个有向无环图

在DFS实现拓扑排序时，用栈来保存拓扑排序的顶点序列；并且保证在某顶点入栈前，其所有邻接点已入栈。

# 排序
### 冒泡排序 
相邻两个元素进行大小比较 若前比后大 则互换

1. 改进一: 处理在排序过程中数组整体已经有序的情况
2. 改进二: 数组局部有序（尾部有序）

```C++
void bubble_sort(vector<int>& arr) { // 优化冒泡
    int traverse = arr.size() - 1;
    for (unsigned int i = 0; i < arr.size(); i ++) {
        int mark = 0; // 标记
        for (int j = 0; j < traverse; j ++) {
            if(arr[j] > arr[j+1]) {
                swap(arr[j], arr[j+1]);
                mark = j + 1;
            }
        } 
        if(!mark) break;
        traverse = mark;
    }
}
```

冒泡是属于交换排序类算法，它重复地走过要排序的数列，一次比较相邻两个元素，如果他俩顺序错误就把他俩交换过来（例如从小到大排列，一次比较就将大的元素排后面，小的元素排前面）一次遍历可以将序列中最大的元素浮到序列的末尾，重复地遍历N次，每一次都可以确定在无序区中最大的元素，将他浮到有序区的第一个元素。所以它的平均时间复杂度是O(n^2)，冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)

冒泡是稳定的排序，当有相邻两个元素大小相等的时候，不做交换，不改变相同大小的数据的前后次序。

算法步骤：

   	1. 比较相邻元素，如果后者比前者小，就交换他们俩个。
            	2. 对无序区每一对相邻元素做同样工作，这样会确定无序区的最大值浮到最后
         	3. 将该最大值划为有序区，针对无序区的所有元素重复以上步骤，直到所有元素都处于有序区。

算法优化：

1. 针对排序过程中，序列整体已经有序：

	使用标记，当一次遍历过程中，没有发生任何交换，说明序列整体有序。结束遍历。

2. 针对排序过程中，无序区的末尾局部已经在物理上属于有序区（即，还没操作它，但该局部序列已经按从小到大排列且最大值比有序区小）每一次遍历无序区时，对无序区右边界的定义为上一次遍历最后一次发送交换的位置

​	



### 选择排序 select sort 
遍历 每次选最大放最后 或最小放最前

```C++
void SelectSort(int arr[], int nLength) {  // 选择排序
    if (arr == NULL || nLength <= 0) return;
    for (int i = 0; i < nLength; i++) {
        int nMin = i;
        for (int j = i; j < nLength; j++) 
            if (arr[j] < arr[nMin]) 
                nMin = j;

        // 交换
        if (nMin != i) 
            swap(arr[i], arr[nMin]);
    }
}
```

### 插入排序 insert sort 
将待排序数据分成两部分，一部分有序一部分无序
将无序元素依次插入到有序中完成排序

Sort插入 适用于元素特别少 ≤15/元素排序前的位置距排好序的最终位置不远的时候使用插入排序

```C++
void InsertSort(int arr[], int nLength) {  // 插入排序
    // 应用场合：
    // 1. 元素特别少的时候， <= 15
    // 2. 元素排序前的位置距其排好序的最终位置不远
    if (arr == NULL || nLength <= 0) return;
    int j;
    for (int i = 1; i < nLength; i++) {
        // j 是有序的最后一个元素 || i 是无序的第一个元素
        int temp = arr[i];                 // 保存元素
        for(j = i - 1;j >= 0 && arr[j] > temp; j --)   // 倒序遍历有序序列
            arr[j + 1] = arr[j];
        arr[j + 1] = temp;
    }
}
```



### 希尔排序 shellsort 
将数据分组，各组内进行插入排序（缩小增量排序）。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

```C++
void ShellSort(int arr[], int nLength) {  // 希尔排序 (缩小增量排序)
    // 希尔排序：将数据分租，各组之内插入排序 
    if (arr == NULL || nLength <= 0) return;
    // 分组间隔
    for (int nGap = nLength >> 1; nGap > 0; nGap = nGap >> 1) 
        // 有nGap组
        for (int i = 0; i < nGap; i++) 
            //各组之内插入排序
            for (int j = i + 1; j < nLength; j += nGap) {
                int k;  // k 是有序的最后一个元素 || j 是无序的第一个元素
                int temp = arr[j];                 // 保存元素
                for (k = j - nGap; k >= i && arr[k] > temp; k -= nGap)   // 倒序遍历有序序列
                    arr[k + nGap] = arr[k];  
                arr[k + nGap] = temp;
            }
}
```



### Countingsort 计数排序 
适用于 分配密集并且重复出现次数较多的数据

（1）找出待排序的数组中最大和最小的元素

（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项

（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）

（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

```c++
void CountingSort(int arr[], int nLength) { // 计数排序 -- 基于非比较的排序
	// 分配密集，并且重复出现次数比较多的数据
    if (arr == NULL || nLength <= 0) return;
    // 最大值 最小值
    int nMin = arr[0];
    int nMax = arr[0];
    for (int i = 1;i < nLength; i ++) {
        if (arr[i] < nMin) nMin = arr[i];
        if (arr[i] > nMax) nMax = arr[i];
    }
    // 计数
    int pMark[nMax-nMin+1] = {0};

    for (int i = 0; i < nLength; i ++) {
        pMark[arr[i] - nMin] ++;
    }
    int p = 0;
    for (int i = 0; i < nMax-nMin+1; i ++) {
    	while(pMark[i]--) {
        	arr[p++] = nMin+i;
        }
    }
}
```

排名 成绩单
1、Min max
2、计数数组
3、排名计算
4、Malloc申请新的空间
5、将数据放到合适的位置 倒序遍历原数组 找到对应的排名位置 将数据放进去 排名-1
6、将新空间的数据放回原数组

### 快速排序
挖坑填补法：小的放左边，大的放右边
主要思想：分治

1.	确定分界点：q[l] q[(l+r)/2] q[r]左边界或者中间值或者右边界
2.	调整区间，使得所有小于等于x的数在x的左边，所有大于等于x的数在x的右边
3.	递归给左边排序，递归给右边排序

不稳定的来源：左右交换的时候，两个相同的数据也会交换

```C++
void QuickSort(int arr[], int l, int r) { // 快速排序
    // 找一个标准值, 将比标准值小的，都放在它的左侧，将比标准值大的，都放在它的右侧
    // 根据标准值位置，将数据分割成两部分，各部分分别重复以上操作
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = arr[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (arr[i] < x);
        do j -- ; while (arr[j] > x);
        if (i < j) swap(arr[i], arr[j]);
    }
    QuickSort(arr, l, j), QuickSort(arr, j + 1, r);
}
```

### 归并排序
将多个有序数组进行合并
1.	确定分界点mid = l+r >> 1;
2.	递归排序，left，right
3.	归并—合二为一
稳定

### 堆排序
> 大顶堆：任一一个父亲的值都比孩子都大   小顶堆：任一一个父亲的值都比孩子都小

1、建堆 
2、浮出堆顶，将堆顶元素与最后一个元素做交换，移出最后一个元素，对堆顶元素做heapify

树型结构用数组来存：  完全二叉树的性质：

>  左孩子在2i+ 1 <= n – 1  右孩子在2i + 2 <= n – 1  父结点在(i - 1) / 2   层数：log2N + 1

```C++
void heapify(int arr[], int nLength, int i) {
    // parent结点为 (i - 1) / 2
    int c1 = 2 * i + 1, c2 = 2 * i + 2; // c1结点为2*i + 1; c2结点为2*i + 2
    int max = i;
    if(c1 < nLength && arr[c1] > arr[max]) max = c1;
    if(c2 < nLength && arr[c2] > arr[max]) max = c2;
    if (max != i) swap(arr[i], arr[max]), heapify(arr, nLength, max);
}
void HeapSort(int arr[], int nLength) {
    // 1. 建大顶堆
    int last_node = nLength - 1;
    int parent = (last_node - 1) >> 1;
    for (int i = parent; i >= 0; i--) {
        heapify(arr, nLength, i);
    }
    // 2. 排序，浮出堆顶元素
    for (int i = nLength -1; i >= 0; i --) {
        swap(arr[i], arr[0]);
        heapify(arr, i, 0); //每次heapify的大小减1, 对根结点进行建堆
    }
}
```



### 桶排序
1. 找出待排序数组中的最大值max、最小值min
2. 拆位，拆出最大值的高位和最小值的高位
3. 申请组，组大小为max高位-min高位+1
4. 元素按高位入组
5. 各组之内进行排序
6. 返回原数组
> 桶排序可用于最大最小值相差较大的数据情况，但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。

```C++
void BucketSort(int arr[], int nLength) { // 桶排序
    if (arr == NULL || nLength <= 0) return;
    // 最大值 最小值
    int nMin = arr[0];
    int nMax = arr[0];
    for (int i = 1;i < nLength; i ++) {
        if (arr[i] < nMin) nMin = arr[i];
        if (arr[i] > nMax) nMax = arr[i];
    }
    // 拆最高位
    int num = nMin;
    int count = 1;
    while(num) {
        num /= 10;
        count *= 10;
    }
    count /= 10;
    int nMinIndex = nMin / count;
    int nMaxIndex = nMax / count;
    // 申请桶空间
    Bucket **pBucket = NULL;
    pBucket = (Bucket**)malloc(sizeof(Bucket*) * (nMaxIndex - nMinIndex + 1));
    memset(pBucket, 0, sizeof(Bucket*) * (nMaxIndex - nMinIndex + 1));

    // 入桶
    Bucket *temp = NULL;
    for(int i = 0; i < nLength; i ++) {
        int index = arr[i]/count-nMinIndex;
        temp = (Bucket*)malloc(sizeof(Bucket));
        temp->nValue = arr[i];
        temp->next = arr[index];
        arr[index] = temp;
    }

    // 桶内排序
    for (int i = 0; i < nMaxIndex - nMinIndex + 1; i ++) {
        Bucket* pNode = pBucket[0];
        Bucket* ptemp = NULL;
        while(pNode->next != NULL) {
            ptemp = pNode;
            while(ptemp->next != NULL) {
                if (ptemp->nValue > ptemp->next->nValue) 
                    swap(ptemp->nValue, ptemp->next->nValue);
                ptemp = ptemp->next;
            }
        }
    }
    // 放回
    int num = 0;
    for (int i = 0; i < nMaxIndex - nMinIndex + 1; i ++) {
        temp = pBucketp[i];
        while(temp) {
            arr[num++] = temp->nValue;
            temp = temp->next;
        }
    }
    // 释放链表空间

}
```



### 基数排序
> 基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。
排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

1. 取得数组中的最大数，并取得位数；
2. arr为原始数组，从最低位开始取每个位组成radix数组；
3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；

```c++
void radixsort(int arr[], int nLength) {//基数排序
    int d = maxbit(arr, nLength); //取得数组中的最大数，并取得位数
    int *tmp = new int[nLength];
    int *count = new int[10]; //计数器
    int k;
    int radix = 1;
    for(int i = 1; i <= d; i++) //进行d次排序
    {
        for(int j = 0; j < 10; j++) count[j] = 0; //每次分配前清空计数器
        for(int j = 0; j < nLength; j++)
        {
            k = (arr[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(int j = 1; j < 10; j++) count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(int j = nLength - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (arr[j] / radix) % 10;
            tmp[count[k] - 1] = arr[j];
            count[k]--;
        }
        for(int j = 0; j < nLength; j++) arr[j] = tmp[j];//将临时数组的内容复制到data中
        radix *= 10;
    }
    delete []tmp;
    delete []count;
}   
```



|排序方法|最好时间复杂度|平均时间复杂度|最坏时间复杂度|空间复杂度|是否稳定(数值相同的两个元素在排序前后其相对位置未发生变化)|
|  ---- |     ----    |    ----     |    ----    |  ----    | ----  |
|冒泡排序|     O(n)    |    O(n^2)   |    O(n^2)  |  O(1)    | 稳定  |
|选择排序|     O(n)    |    O(n^2)   |    O(n^2)  |  O(1)    | 不稳定|
|插入排序|     O(n)    |    O(n^2)   |    O(n^2)  |  O(1)    | 稳定  |
|希尔排序|     O(n)    |    O(nlogn)   |    O(ns)  |  O(1)   |不稳定 |
|计数排序|     O(n+k)    |    O(n+k)   |    O(n+k)  |O(n+k)  | 稳定  |
|快速排序|     O(nlogn)    |    O(nlogn)   |    O(n^2)  | O(nlogn)   | 不稳定  |
|归并排序|     O(nlogn)    |   O(nlogn)  |   O(nlogn)  |  O(n)   | 稳定  |
| 堆排序 |     O(nlogn)    |   O(nlogn) |  O(nlogn) | O(1)   | 不稳定  |
| 桶排序 |     O(n)    |  O(n) |    O(n)  |  O(m)   | 稳定  |

#### Top K问题：一万个元素 前五个最大的
- 方法：

	1. 构建堆

	  我们知道完全二叉树有几个非常重要的特性，就是假如该二叉树中总共有N个节点，那么该二叉树的深度就是log2N，对于小顶堆来说移动根元素到 底部或者移动底部元素到根部只需要log2N，相比N来说时间复杂度优化太多了
	
	  将前5个数插入到小顶堆，随后从第6个数进行遍历，如果当前遍历到的数比小根堆的堆顶的数要大，就把堆顶的数弹出，再插入当前遍历到的数。最后将小根堆里的数存入数组返回即可。
	2. 快排
	3. 暴力(遍历5次，分别找最大，第二大，…)
	4. 五个元素的数组 新元素与min比较
				
	

# 动态规划

DynamicProblemming （DP问题）

求最优解（最小，最大，最长，最短，最多，最少等等）

空间换时间（时空权衡）

**将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解**。

- 动态规划两大特性

	1、无后效性：过去不影响将来（某一状态被确定，这个状态怎么求出来的再也不关心了

​	   2、最优子结构性质：子问题的最优解构成当前问题的最优解

**例子**：面值1，5， 11中凑15，求最少张数

状态  F(i) 

状态转移方程  F(i) = min { F(i-1) +1 , F(i-5)+1 , F(i-11)+1 }

F(i) = min{F(i - v[j]) + 1} (v[j] <= i)

​											集合

​		状态表示f（v，j）

​											属性：最小，最大，最长，最短，最多，最少

DP

​		状态计算



### 题1：最长	递增子序列

f(i) = max { f(j) + 1, 1 } (v[j] <= v[i] && 0 <= j && j < i)

### 题2：捡苹果

|  R   |      |      |      |      |      |      |      |
| :--: | ---- | ---- | ---- | ---- | ---- | ---- | :--: |
|      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |  R   |



### 题3：最长公共子序列

X: BCAADCB	m

Y:CADDBC		n

假设Zk是Xm，Yn的LCS

若Xm = Yn = Zk	Zk-1 是 Xm-1 Yn-1的LCS

Xm != Yn Zk 是max{Xm-1Yn	,  XmYn-1 }



# 最大流 Maximum Flow

在一个有向图上选择一个**源点**，一个**汇点**，每一条边上都有一个流量上限（以下称为**容量**），即经过这条边的流量不能超过这个上界，同时，除源点和汇点外，所有点的入流和出流都**相等**，而源点只有流出的流，汇点只有汇入的流。这样的图叫做**网络流**。

> 源点：只有流出去的点
> 汇点：只有流进来的点
> 流量：一条边上流过的流量
> 容量：一条边上可供流过的最大流量
> 残量：一条边上的容量-流量

- 经过边的流不能超过边的容量；
- 除了源点 s 和汇点 t，对于其它所有顶点，流入量与流出量要相等；

### Ford-Fulkerson算法

依赖于三种重要思想：

1. 残留网络（Residual networks）
2. 增广路径（Augmenting paths）
3. 割（Cut）

开始时，对所有 u, v ∈ V 有 f(u, v) = 0，即初始状态时流的值为 0。在每次迭代中，可通过寻找一条增广路径来增加流值。增广路径可以看做是从源点 s 到汇点 t 之间的一条路径，沿该路径可以压入更多的流，从而增加流的值。反复进行这一过程，直至增广路径都被找出为止。

步骤：

1. 随意选取一条简单路径
2. 找到这条路径的瓶颈值
3. 更新残留Graph，添加反向边（反向边可以被使用）
4. 重复上述3步

### Dinic算法

Dinic算法引入了一个叫做**分层图**的概念。具体就是对于每一个点，我们根据从源点开始的bfs序列，为每一个点分配一个深度，然后我们进行若干遍dfs寻找增广路，每一次由u推出v必须保证v的深度必须是u的深度+1。

步骤：

1. 画出残留Graph
2. 根据残留Graph画出分层图LG
3. 由分层图LG画出Blocking Flow（阻塞流）
4. 由阻塞流更新残留Graph，添加反向边

# 二分图

二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。 

- 二分图的最大匹配有2种实现，网络流和匈牙利算法。

	1. 匈牙利算法

		匈牙利算法是求解最大匹配的有效算法，该算法用到了增广路的定义(也称增广轨或交错轨)：若边集合P是图G中一条连通两个未匹配顶点的路径，并且属M的边和不属M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径。(（举例来说，有A、B集合，增广路由A中一个点通向B中一个点，再由B中这个点通向A中一个点……交替进行）。

由增广路径的定义可以推出下述三个结论：

	1. P的路径长度必定为奇数，第一条边和最后一条边都不属于M。
	
	2. P经过“取反操作”（即非M中的边变为M中的边，原来M中的边去掉）可以得到一个更大的匹配M’。

# Algorithm

#### [剑指 Offer 03. 数组中重复的数字](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

- 方法：

	1. 暴力，先排序数组，遍历数组当前元素与下一元素是否相同，相同说明重复
	2. 原地交换，索引和值形成映射

	> 遍历数组 numsnums ，设索引初始值为 i = 0i=0 :
	>
	> 若 nums[i] = inums[i]=i ： 说明此数字已在对应索引位置，无需交换，因此跳过；
	> 若 nums[nums[i]] = nums[i]： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i]，即找到一组重复值，返回此值 nums[i] ；
	> 否则： 交换索引为 i 和 nums[i]的元素值，将此数字交换至对应索引位置。
	> 若遍历完毕尚未返回，则返回 -1 。

#### [剑指 Offer 04. 二维数组中的查找](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

- 方法：

	1. 暴力查找---> 未利用数组特点

	2. 线性查找：讲二维数组逆时针旋转45°可以看成一棵BST，由二维数组的右上角开始查找可以保证不漏一个元素。![](https://pic.leetcode-cn.com/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png)

		步骤：

		1. 若数组为空，返回 `false`
		2. 初始化行下标为 0，列下标为二维数组的列数减 1
		3. 重复下列步骤，直到行下标或列下标超出边界
			- 获得当前下标位置的元素 `num`
			- 如果 `num` 和 `target` 相等，返回 `true`
			- 如果 `num` 大于 `target`，列下标减 1
			- 如果 `num` 小于 `target`，行下标加 1

#### [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

- 方法：
	1. 直接遍历，构造一个结果字符串



#### [剑指 Offer 06. 从尾到头打印链表](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

- 方法:

	1. 顺序遍历，存入vector数组中，用C++ <algorithm> 函数reverse函数反转vector数组实现倒序打印

	2. 递归，通过递归的回溯过程，从下到上，将每一层的val加入到vector数组内，传递给上一层

	3. 辅助栈，利用栈的“先进后出”特点，实现倒序打印

#### [剑指 Offer 07. 重建二叉树](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)

- 方法：

	1. 分治，

	> 前序遍历的首元素 为 树的根节点 node 的值。
	> 在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。
	> 根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ] 。

	通过这三步，可以确定**根结点，左子树根结点，右子树根节点**

	对于左右子树，可以复用上述方法划分子树的左右子树

	

#### [剑指 Offer 10- I. 斐波那契数列](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)

- 方法：

	1. 递归 --> **超时**

	> 递归公式：F(n) = F(n-1) + F(n-2) 且F(0) = 0 , F(1) = 1
	>
	> 终止条件：n = 0 or n = 1

	2. 滚动数组

#### [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

- 方法：
	1. 斐波那契数列问题	（F(0) = 0, F(1) = 1 F(2) = 2)

#### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

- 方法：
	1. 双指针：第一个指针指向head结点，第二个指针指向head后第k个结点，当第二个指针移动到NULL时，head指针指向链表中倒数第k个节点

#### [剑指 Offer 18. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

- 方法：
	1. 暴力：遍历链表，找到head->next->val == val 的结点，更改head的next指针
	2. 

#### [剑指 Offer 24. 反转链表](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)

- 方法:
	
	 1. 顺序遍历，将val存入vector数组，再新生成新链表————**超时**
	
	 2. 递归
	
		递推公式：
	
		> ```reasonml
		> 令F(node)为问题:反转以node为头节点的单向链表；
		> 一般，我们需要考虑F(n)和F(n-1)的关系，那么这里，如果n代表以node为头节点的单向链表，那么n-1就代表以node.next为头节点的单向链表.
		> 所以，我们令F(node.next)为问题：反转以node.next为头节点的单向链表；
		> 那么，F(node)和F(node.next)之间的关系是？这里我们来简单画个图，假设我们反转3个节点的链表：
		> 1 -> 2 -> 3 -> null
		> 那么，F(node=1)=F(node=2)+?
		> F(node=1) = 3 -> 2 -> 1
		> F(node=2) = 3 -> 2
		> 这里假设子问题F(node=2)已经解决，那么我们如何解决F(node=1)：
		> 很明显，我们需要反转node=2和node=1， 即 node.next.next=node; 同时 node.next=null;
		> 所以，这个问题就可以是：F(node=1)=F(node=2)+ 反转node=2和node=1
		> ```
	
		终止条件：
	
		链表遍历到尾 -> head == NULL(边界情况：传入的head为null) || head->next == NULL
	
	3. 栈或者是数组去记录val，再次遍历链表，修改val
	4. 栈保存结点，修改结点间指向关系
	5. 三个指针(第一个指针：反转后被指向的结点 第二个指针：反转后指向结点 第三个指针：反转后被断开的结点)
	

#### [剑指 Offer 25. 合并两个排序的链表](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

- 方法：

	1.  迭代，设定一个哨兵节点记录合并后的头结点，维护一个head指针，调整它的next指针，记录两个链表中更小的一个

	2. 递归

		> 递归公式：
		> { list1[0]+merge(list1[1:],list2)		list1[0]<list2[0]
		> { list2[0]+merge(list1,list2[1:])		otherwise

#### [剑指 Offer 35. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

- 方法：
	1. 暴力，用二维数组存下next和random指针 ---> **没做出来**
		1. 原地修改，1->1'->2->2'->3->3'    ， 
	2. 将原链表与复制后的链表的结点进行key-value映射

#### [剑指 Offer 09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

- 方法：
	1. stack1 负责入队， stack2负责出队，push操作压入stack1，pop操作
		- 如果stack2为空，将stack1push到stack2再pop
		- 如果stack2不为空，直接弹出队头元素

#### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

- 方法：

	queue1 和 queue2 维护一个队列queue2为空

	push(): 往queue1中插入元素

	pop():如果queue1有元素，弹出队头元素直到queue1中还剩一个元素，该值即为要弹出的元素，pop后用swap维护queue2为空。

	empty()：return queue1.empty()

#### [剑指 Offer II 085. 生成匹配的括号](https://leetcode.cn/problems/IDBivT/)

- 方法：
	1. 动态规划

#### [946. 验证栈序列](https://leetcode.cn/problems/validate-stack-sequences/)

- 方法：

	1. 模拟栈，

		 数组pushed 和 popped 的如下性质：
		> 数组pushed 中的元素互不相同；
		>
		> 数组popped 和数组pushed 的长度相同；
		>
		> 数组 popped 是数组pushed 的一个排列。

		可以得到如下结论：

		> 栈内不可能出现重复元素；
		>
		> 如果pushed 和popped 是有效的栈操作序列，则经过所有的入栈和出栈操作之后，每个元素各入栈和出栈一次，栈为空。
		
		验证栈序列的模拟做法如下：
		
		> 遍历数组 pushed，将 pushed 的每个元素依次入栈；
		>
		> 每次将 pushed 的元素入栈之后，如果栈不为空且栈顶元素与popped 的当前元素相同，则将栈顶元素出栈，同时遍历数组popped，直到栈为空或栈顶元素与popped 的当前元素不同。
		
		push操作可以从pushed数组从取元素，当栈不为空且栈顶元素与popped数组第一个元素相等时，执行pop()操作

#### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

- 方法：

	中序遍历： 左根右

	1. **递归**： 

		> 结束条件：root指针指向NULL

	2. **迭代**：与递归等价，区别在于，递归隐式地维护了一个栈，迭代需要显示的将这个栈模拟出来

		步骤：

		循环   **循环条件：head != NULL || !st.empty()**

		1. 遍历左的左一直到NULL，将过程所有经过的结点依次入栈

		2. 判断栈是否为空

			​	如果不为空，将栈顶元素存入res数组中，弹出栈顶元素，将head指针指向栈顶元素的右孩子，重复上述步骤

#### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

- 方法： 在层序遍历的基础上要实现输出按层打印
	1. 借助辅助队列实现层序遍历
		1. Root结点入队
		2. pop队首元素，将左右非空孩子结点入队
		3. 重复第二步
	2. 实现按层打印，定义变量curLevelSize 记录当前 队列大小， 在pop队首元素时弹出curLevelSize那么多队首，即为一层

#### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

- 一棵高度平衡二叉树定义为：一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

	结论：一棵二叉树是平衡二叉树，当且仅当每一棵子树也都是平衡二叉树

- 方法：**递归**

	1. 自顶向下：

		定义函数height，用于计算二叉树中的任意一个节点 *p* 的高度：

$$
height(p)=
\begin{cases}
0,    p == NULL\\
max(height(p.left, p.right) + 1),  p != NULL\\
\end{cases}
$$

> 有了计算节点高度的函数，即可判断二叉树是否平衡。
> 具体做法类似于二叉树的前序遍历。
> 对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。左右子树平衡，即可证明该树为二叉平衡树。

2. 自底向上：

	方法一由于是自顶向下递归，因此对于同一个节点，函数height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数height 只会被调用一次。

	自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。

#### [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

方法： 在层序遍历的基础上要实现输出按层打印

1. 借助辅助队列实现层序遍历
	1. Root结点入队
	2. pop队首元素，将左右非空孩子结点入队
	3. 重复第二步
2. 实现按层打印，定义变量curLevelSize 记录当前 队列大小， 在pop队首元素时弹出curLevelSize那么多队首，即为一层
3. 用C++ reverse()获取反转后的res

#### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

- 方法：

	1. 暴力：将数组中位数作为二叉搜索树的root结点，再对剩余结点做插入————**超时**

		没有利用有序数组的特点

	2. 递归：

		每次选数组最中间数或者是最中间左边那个数为根节点，可以保证左右两个子树结点数相等或者只相差一个，每次递归的去处理左右两个子树，选出子树的根结点作为根结点的左右孩子。

		结束条件，给出的子树数组范围的left < right

		优化：int mid = (left + right) / 2 可以改成int mid = (left + right) >> 1;

#### [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

- 方法：

	利用BST的中序遍历结果有序的特点，先求出BST的中序结果，进而返回BST中第k小的元素，即res[k-1]

#### [100. 相同的树](https://leetcode.cn/problems/same-tree/)

- 方法：

	1. DFS：

		- 递归公式：

$$
isSameTree(n) = 

\begin{cases}

isSameTree(n.left)\ \&\&\ isSameTree(n.right), if(p.val == q.val)\\
false, if(p.val != q.val)\\

\end{cases}
$$
结束条件：

```c++
if(p == NULL && q == NULL) return true;
else if((p == NULL && q != NULL) || (p != NULL && q == NULL))return false;
```

#### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

- 方法：

	1. 猜测对称的二叉树中序遍历结果对称，但是还有一类不对称的二叉树其val相等，其中序遍历结果依然对称。**中序遍历结果无法证明该二叉树对称**

	2. 递归：

		对称的树满足的性质：

		1. 某一结点与他对称的结点相等。

		2. 某一结点的左子树与与他镜像的结点的右子树相等。

		用两个指针来标记两个镜像的结点，同时移动。

#### [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

- 方法：
	1. 递归：将二叉树展开为单链表之后，单链表中的节点顺序即为二叉树的前序遍历访问各节点的顺序。因此，可以对二叉树进行前序遍历，获得各节点被访问到的顺序。由于将二叉树展开为链表之后会破坏二叉树的结构，因此在前序遍历结束之后更新每个节点的左右子节点的信息，将二叉树展开为单链表。
	2. 遍历同时展开：后序遍历+递归。先递归左右子树，再对当前结点做判断和展开为链表



#### [207. 课程表](https://leetcode.cn/problems/course-schedule/)

课程安排图是否是 有向无环图(DAG)。
思路：通过 拓扑排序 判断此课程安排图是否是 有向无环图(DAG) 。

拓扑排序原理： 对 DAG 的顶点进行排序，使得对每一条有向边 (u,v)，均有 u（在排序记录中）比 v 先出现。亦可理解为对某点 v 而言，只有当 v 的所有源点均出现了，v 才能出现。
通过课程前置条件列表 prerequisites 可以得到课程安排图的 邻接表 adjacency，以降低算法时间复杂度，以下两种方法都会用到邻接表。

- 方法：

	1. 入度表（BFS）

		统计课程安排图中每个节点的入度，生成 入度表 indegrees。
		借助一个队列 queue，将所有入度为 0 的节点入队。
		当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：
		并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 −1，即 indegrees[cur] -= 1。
		当入度 -1−1后邻接节点 cur 的入度为 00，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。
		在每次 pre 出队时，执行 numCourses--；
		若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。
		因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。

	2. DFS

		统计课程安排图中每个节点的入度，生成 入度表 indegrees。
		借助一个队列 queue，将所有入度为 0 的节点入队。
		当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：
		并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 −1，即 indegrees[cur] -= 1。
		当入度 -1−1后邻接节点 cur 的入度为 0，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。
		在每次 pre 出队时，执行 numCourses--；
		若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 00。
		因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。

#### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

- 方法：

	1. 双指针：数组是有序的，那么重复的元素一定会相邻

		比较 p 和 q 位置的元素是否相等。

		如果相等，q 后移 1 位
		如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位
		重复上述过程，直到 q 等于数组长度。

		返回 p + 1，即为新数组长度。

	2. 异或：

	3. 每次将相邻位置的两个数进行异或运算，如果结果为0就说明两个位置的数相等，不做任何处理，如果两个位置的数不相等则进行赋值运算。在这我们使用了两个变量p,q,因为每次都是两个数参与运算，所以如果两个数不相等的话我们就可以直接把这两个数赋值给数组num


#### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

- 方法：

	1. 双指针，前一个结点在后一个结点的第k个

		如果我们能够得到的是倒数第 n个节点的前驱节点而不是倒数第 n 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将*back* 指向哑节点，其余的操作步骤不变。

#### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

- 方法：

	1. 双指针: 

		由于题目要求删除数组中等于 val 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。

		if right != val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；

		if right == val，它不能在输出数组里，此时left不动，right右移一位。

#### [705. 设计哈希集合](https://leetcode.cn/problems/design-hashset/)

(1) 确定散列函数 求整取余 p=key%m（为了尽可能避免冲突，应当将m取为一个质数。）

(2) 确定处理哈希冲突的办法（一般拉链法）

①  开放地址法：当发现哈希值 hh 处产生冲突时，根据某种策略，从 hh 出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查 h+1,h+2,h+3,… 这些整数对应的位置。

1) 线性探测

2) 二次探测

②  拉链法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。

扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。

#### [706. 设计哈希映射](https://leetcode.cn/problems/design-hashmap/)

- 方法：
	1. 暴力一维数组，适合于本身key值范围较小的情况。
	2. 二维数组，稀疏数组节省空间。
	3. 拉链法，对于hash到同一个key的元素，用链表链起来，增加查找删除时要遍历每个key所对应的linkedList链表。
	4. 开放定址法，线性探测

#### [14. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

- 方法：

	1. 暴力：
		当字符串数组长度为 0 时则公共前缀为空，直接返回
		令最长公共前缀 res的值为第一个字符串，进行初始化
		遍历后面的字符串，依次将其与 res进行比较，两两找出公共前缀，最终结果即为最长公共前缀
		如果查找过程中出现了 res为空的情况，则公共前缀不存在直接返回
		时间复杂度：O(s)，s 为所有字符串的长度之和

#### [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

- 方法：

	1. 暴力：枚举原串 ss 中的每个字符作为发起点，每次从原串的发起点和匹配串的首位开始尝试匹配：

	  匹配成功：返回本次匹配的原串发起点。
	  匹配失败：枚举原串的下一个发起点，重新尝试匹配。

	2. KMP：

#### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

- 方法：

	1. 动态规划：

		dp\[i\]\[j]表示从左上角出发到 (i,j)(*i*,*j*) 位置的最小路径和

		状态转移方程:

	> 当 i>0i>0 且 j=0j=0 时，dp\[i\]\[0]=dp\[i-1\]\[0]+grid\[i\]\[0]dp\[i\]\[0]=dp\[i−1\]\[0]+grid\[i\]\[0]。
	> 当 i=0i=0 且 j>0j>0 时，dp\[0\]\[j]=dp\[0\]\[j-1]+grid\[0\]\[j]dp\[0\]\[j]=dp\[0\]\[j−1]+grid\[0\]\[j]。
	> 当 i>0i>0 且 j>0j>0 时，dp\[i\]\[j]=min(dp\[i-1\]\[j],dp\[i\]\[j-1])+grid\[i\]\[j]dp\[i\]\[j]=min(dp\[i−1\]\[j],dp\[i\]\[j−1])+grid\[i\]\[j]。

最后得到 dp\[m-1\]\[n-1]dp\[m−1\]\[n−1] 的值即为从网格左上角到网格右下角的最小路径和。

#### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

- 方法：

	1. 反转链表的思路，反转链表的后半段，然后跟原链表一一比较

	2. 双指针：将值复制到数组中后用双指针法，pre指针指向数组首元素，back指针指向数组末尾元素，遍历数组比较

		​	如果指针指向的值相同，pre = pre + 1；back = back - 1；

​					如果不同， 返回false；

#### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

- 方法：
	1. 递归：

		终止条件是：链表中没有节点，或者链表中只有一个节点，此时无法进行交换。

		用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。

#### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

- 方法：

	1. 单调栈：

		可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。

		由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。

#### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

- 方法：

	1. DP

		f(i)为考虑前 i 个元素，以第 i个数字结尾的最长上升子序列的长度

状态转移方程为：

```
f(i) = max { f(j) + 1, 1 } 且 (v[j] <= v[i] && 0 <= j && j < i)
```

最后，整个数组的最长上升子序列即所有f[i] 中的最大值。

#### [剑指 Offer II 095. 最长公共子序列](https://leetcode.cn/problems/qJnOS7/)

方法：

1. DP

X: BCAADCB	m

Y:CADDBC		n

假设Zk是Xm，Yn的LCS

若Xm = Yn = Zk	Zk-1 是 Xm-1 Yn-1的LCS

Xm != Yn Zk 是max{Xm-1Yn	,  XmYn-1 }


# Tree路线图

## 1. 遍历二叉树

#### [100. 相同的树](https://leetcode.cn/problems/same-tree/)

1. 递归dfs：

	递归公式：

$$
isSameTree(n) = 

\begin{cases}

isSameTree(n.left)\ \&\&\ isSameTree(n.right), if(p.val == q.val)\\
false, if(p.val != q.val)\\

\end{cases}
$$

​		结束条件：

```c++
if(p == NULL && q == NULL) return true;
else if((p == NULL && q != NULL) || (p != NULL && q == NULL))return false;
```

2. BFS：

	循环条件：!queue1.empty() && !queue2.empty()
	
	```C++
	if(a->val != b->val) return false;
	else if (a->val == b->val && ((a->left==NULL)^(b->left==NULL)|| ((a->right==NULL)^(b->right==NULL)))) return false;
	else {
		if (a->left != NULL) {
	    	queue1.push(a->left);
	    	queue2.push(b->left);
	    }
	    if (a->right != NULL) {
	    	queue1.push(a->right);
	    	queue2.push(b->right);
	    }
	}
	```
	
	return queue1.empty() && queue2.empty()
	

#### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

1. 递归：

	对Root的左右子树Left和Right做递归

	结束条件：

	```C++
	if(Left==NULL && Right == NULL) return true;
	else if(Left == NULL || Right == NULL) return false;
	```

	递归公式：
	$$
	isSame(Left, Right) =
	\begin{cases}
	
	false, if(Left.val != Right.val)\\
	isSame(Left.left, Right.right)\ \&\&\ isSame(Left.right, Right.left), else
	
	\end{cases}
	$$
	代码：

	```c++
	class Solution {
	public:
	    bool isSame(TreeNode* Left, TreeNode* Right) {
	        if(Left==NULL && Right == NULL) return true;
	        else if(Left == NULL || Right == NULL) return false;
	        if(Left->val == Right->val) {
	            return isSame(Left->left, Right->right) && isSame(Left->right, Right->left);
	        }
	        return false;
	    }
	    bool isSymmetric(TreeNode* root) {
	        if(root == NULL) return true;
	        return isSame(root->left, root->right);
	    }
	};
	```

#### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

1. DFS：

	深度优先遍历左右子树，返回子树的最大高度，结果+1.

	结束条件：

	```
	if (root == NULL) return 0;
	```

	递归公式：
	$$
	maxDepth(root) = max(maxDepth(root->left),maxDepth(root->right)) + 1
	$$

2. BFS：

	广度优先遍历时，每次从queue中拿出队列里的所有节点，保证队列存放「当前层的所有节点」，维护一个变量ans，每次取出结点时+1；

	```C++
	while(!queue.empty()) {
		int size = queue.size();
	    while(size --) {
	    	TreeNode* node = queue.front();
	        queue.pop();
	        if (node->left != NULL) queue.push(node->left);
	        if (node->right != NULL) queue.push(node->right);
	    }
	    ans ++;
	}
	```

	

#### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

1. 自顶向下递归：

	树是否平衡取决于root的左右子树是否平衡

	root的左子树是否平衡取决于左子树的左右子树是否平衡(左右子树是否平衡可以看左右子树跟结点的高度差)

结束条件：

```C++
if(root == NULL || (root->left == NULL && root->right == NULL)) 
	return true;
if(abs(maxLength(root->left)-maxLength(root->right)) > 1) return false;
```

递归公式：

```C++
isBalanced(root) = isBalanced(root->left) && isBalanced(root->right);
```

2. 自底向上递归：

	类似于后序遍历，先判断左右子树是否符合平衡，再对当前结点进行判断

	结束条件：

	```C++
	 if(root == NULL || ((root->left == NULL) && (root->right == NULL))) return true;
	```

	递归公式：
	
	1. 如果左右子树平衡
		- abs(maxLength(root->left)-maxLength(root->right)) > 1 ， false
		- true
	2. 不平衡，false

#### [112. 路径总和](https://leetcode.cn/problems/path-sum/)

1. DFS:

	结束条件：

	```C++
	if (root == NULL) return false;
	if (root->left == NULL && root->right == NULL) {
		return targetSum == root->val;
	}
	```

	递归公式：

	```c++
	hasPathSum(root) = hasPathSum(root->left, targetSum-root->val) || hasPathSum(root->right, targetSum-root->val);
	```

2.  BFS:

	两个队列，一个队列queue1遍历所有结点，另一个队列queue2存放每一个结点对应的根结点到该结点路径上所有结点的结点和

	当遍历到叶子结点，判断结点和是否等于targetSum

#### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

1. 自底向上翻转：

	类似于后序遍历，从下向上翻转每一个子树。

	当遍历到root结点时，root的左右子树都已经交换，可以直接交换左右子树。

#### [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

1. 中序遍历确定一个升序序列，**任意两不同节点值之间的最小差值** 即为：

	有序序列中相邻两元素的最小差值。

#### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

1. 深度优先搜索+最大深度

	二叉树的直径：任意两个结点路径长度中的最大值 == 这两个节点的根节点的左右子树的最大深度之和

	遍历每一个节点，求每一个节点的左右子树的最大深度之后的最大值
	$$
	diameterOfBinaryTree = max(maxDepth(node->left)+maxDepth(node->right))\\
	 maxDepth(root) = max(maxDepth(root->left),maxDepth(root->right)) + 1
	$$

​		使用一个全局变量，记录每一个节点的左右子树的最大深度之和的最大值

时间复杂度O(n):n 为二叉树的节点数，即遍历一棵二叉树的时间复杂度，每个结点只被访问一次。

空间复杂度O(height):空间复杂度取决于递归的深度，递归的深度就是树的高度，每次递归只调用常数个变量

#### [563. 二叉树的坡度](https://leetcode.cn/problems/binary-tree-tilt/)

1.  深度优先遍历

	1. 使用全局变量记录所有结点的坡度之和

	遍历当前结点，得到左子树结点之和，右子树结点之和 

	将左子树结点之和与右子树结点之和的差的绝对值累加到结果变量 ans；

	递归公式：
	$$
	dfs(root) = dfs(root->left) + dfs(root->right) + root->val
	$$

​		结束条件：root == NULL

​		返回以当前结点 作为根结点的树的结点之和
