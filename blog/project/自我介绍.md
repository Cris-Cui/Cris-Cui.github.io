# 基本情况介绍

面试官您好! 很荣幸有这个机会参与应聘贵公司的C++开发工程师一职，感谢面试官您和贵公司给我的这次面试机会，我先做一个自我介绍，我叫崔孝俊，来自哈尔滨理工大学网络工程专业，在校期间我担任班长一职，主要负责我们班级的一些日常管理和协助辅导员做一些班级情况的汇报，在学习上我的专业排名在专业前10%，多次获得校园奖学金和哈尔滨银行奖学金，还获得了三好学生的荣誉称号，我的主修课程是计算机网络，操作系统，数据结构与算法等，在学习了计算机网络后，对网络编程比较感兴趣，基于计网和Linux操作系统，我做了一个轻量级TCP Socket服务器，然后再基于这个服务器做了一个IM这样比较经典的业务项目。面试官您看我能跟您展开聊聊我的这两个项目吗?

# 项目简介

## 第一个项目

首先是这个轻量级TCP Socket服务器，我基于面向对象思想，主要做了三个大的板块，一个是服务器框架的基础板块工欲善其事，必先利其器嘛，我做了包括日志模块，配置模块，环境变量模块，这对后期的debug和配置奠定了一个基础。

第二个是针对服务器做的性能优化模块，我称之为高并发模块，包括线程模块，线程安全模块，协程模块，协程调度模块，IO协程调度模块，Hook模块，定时器模块。

第三个是网络库模块，包括网络地址Address模块，Socket模块和TCPServer模块。

服务器的网络模型是Reactor+线程池模式，IO处理是使用了非阻塞同步IO和IO多路复用技术。服务器目前具备高性能，可扩展性和易用性等特点。我在后面实现服务端的业务功能时，只需要继承TCPServer就可以写自己的业务代码了。然后我对网络库进行了压力测试，

### 项目难点

在项目中我的工作分为两部分：

1.  一部分是服务器的一些基本框架，网络库的搭建，这部分的难度是技术的理解和选型，以及去学习一些开源的框架，来应用到项目中，比如我在日志模块的搭建中参考了Log4J的思想。在配置模块搭建中
2.  另一部分是为了提高服务器性能所做的一些优化，例如Epoll+线程池

### 项目中遇到的困难,是如何解决的？

1.  ⼀⽅⾯是对不同的技术理解不够深刻，难以选出最合适的技术框架。这部分的话我主要是反复阅读作者在GitHub提供的⼀些技术⽂档，同时也去搜索⼀些技术对⽐的⽂章去看
2.  另⼀⽅⾯是编程期间遇到的困难，在代码编写的过程中由于⼯程能⼒不⾜，程序总会出现⼀些bug。这部分的话我⾸先是通过⽇志去定位bug，然后推断bug出现的原因并尝试修复，如果是⾃⼰⽬前⽔平⽆法修复的bug，我会先到⽹上去查找有没有同类型问题的解决⽅法，然后向同学或者直接到StackOverflow等⼀些国外知名论坛上求助。

### 针对项目做了哪些优化？

1\. 程序本身

减少程序等待 IO 的事件：Hook + 阻塞 IO + IO 多路复⽤

设计⾼性能⽹络框架，同步 IO（reactor + 线程池）和 协程 ，实现以同步IO达到异步的性能，这里之所以不直接使用异步IO有两点：1.本身在课程的学习上对同步IO的掌握程度要高于异步IO 2.

【减少系统调⽤】避免频繁创建/销毁线程：线程池

【减少系统调⽤】对于⽂件发送，使⽤零拷⻉函数 sendFile() 来发送，避免拷⻉数据到⽤户态

【减少系统调⽤】尽量减少锁的使⽤，如果需要，尽量减⼩临界区（⽇志系统和线程池），对简单类型的共享资源访问可以使用C++11的原子类型，在底层用了无锁编程的思想，通过CAS来实现的。

2\. 系统参数调优(修改）

最⼤⽂件描述符数（⽤户级和系统级）

tcp 连接的参数（半连接/连接队列的⻓度、tcp syncookies）

### 谈谈你在项目中用到的协程？

**首先中项目中针对协程的使用，做了五个封装，分别是协程模块，协程调度模块，IO协程调度模块，Hook模型，定时器模块**

**首先是最基本的**

#### **协程模块**

我将从协程的基本概念，我为什么要使用协程，以及我在实现过程中的一些细节问题这三个方面来详细讲解。

##### 协程的概念

首先在我的理解，协程是一种**看上去花里胡哨使用上也花里胡哨的函数** ，何出此言，可以看成**可中断的函数**。

可以在执行过程中暂停，并且在需要的时候恢复执行

相较于普通函数**从头到尾的执行**(普通函数从入口进入，遇到作用域结束)，协程可以根据需求在执行过程中主动暂停(yield)，并且在需要的时候恢复执行(resume). 线程执行调度任务的效率就更高，可以避免一些不必要的阻塞，提高当前程序对于CPU的使用效率。

协程的主要思想：**控制流的主动让出和恢复。**

协程与进程和线程的区别

1.  **调度方式**

    *   进程是操作系统分配资源的最小单位，进程切换由操作系统进行调度

    *   线程是最小的执行单位，线程切换由操作系统进行调度，但比进程切换开销小很多(

        1.  因为线程切换只需要保存当前线程栈和寄存器，同一个进程内的全局资源在多线程之间共享

        2.  上下文切换速度快，因为线程共享进程的地址空间，上下文切换主要涉及寄存器和线程栈，而不需要切换页表等底层数据结构

        3.  线程同步主要通过共享内存和同步原语(锁，条件变量)，而进程同步需要更复杂的IPC(管道，消息队列，共享内存)

            )

    *   协程的上下文切换由程序自身控制，对内核不可见，切换开销最小，可以在一个线程内执行多个协程任务(并发而不是并行，多个协程共享线程的时间片)

2.  **资源占有**：

    *   进程之间相互独立，每个进程有自己独立的用户空间内存空间(32位操作系统虚拟内存0-3G，内核空间进程间共享)
    *   线程共享进程的内存空间，每个线程有自己独立的线程栈(位于进程虚拟用户空间的栈区)
    *   协程共享线程的内存空间

##### 为什么要使用协程

然后我在项目初期使用的没用应用任何网络框架，epoll+非阻塞IO，多线程+callback，协程相较于这种方式就是执行流上下文切换相对于线程切换时资源消耗较少

##### 实现细节

那么在实现上，我是基于linux的ucontext库来实现的一个非对称协程。核心操作是两个切换操作，yield和resume，使用ucontext的swapcontext来完成，将当前寄存器和协程栈保存在一个上下文中，并且切换到另一个上下文来完成操作。

那么这样一个非对称协程使用时的注意事项：

非对称协程模型子协程不能resume另一个子协程。

在协程中不能使用线程级别的锁，当某个协程获取了锁后让出CPU后，会阻塞整个线程无法继续。

#### **协程调度模块**

所谓协程调度，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务)

在前面的协程模块中，对于每个协程，都需要用户手动调用协程的resume方法将协程运行起来，然后等协程运行结束并返回，再运行下一个协程。这种运行协程的方式其实是用户自己在挑选协程执行，相当于用户在充当调度器，显然不够灵活.因此需要实现一个调度器来完成调度工作。

调度器和核心思想是线程池+任务队列。用户在使用协程时只需要直接向任务队列中放任务。多线程并发的在任务队列中取到协程任务去执行。如果某个协程在执行过程中主动退出了，那么当前线程就可以继续去任务队列中取任务而无需等待。

这个模块的一些优点：

*   支持将caller线程放到线程池中执行任务调度。

但这个模块存在一些问题：

*   协程主动退出，必须在退出前主动将自己重新加入到任务队列，否则该协程任务将会永远无法被调度。
*   任务队列为空时，线程池需要忙等待。对CPU

#### IO协程调度模块

继承自协程调度器，对协程调度器的改造，将epoll与协程调度融合，重新实现tickle和idle，并保证原有的功能不变。

基于epoll实现IO事件的添加、删除、调度、取消等功能。

IO协程调度还解决了调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。

#### 定时器模块

通过定时器可以实现给服务器注册定时事件，这是服务器上经常要处理的一类事件，比如3秒后关闭一个连接，或是定期检测一个客户端的连接状态。

## 第二个项目

### 文件传输

#### 客户端上传

用户选取文件-> 获取文件信息(文件名，文件大小，文件MD5信息摘要)——》给服务器发送请求包，——》服务器根据MD5值查询该文件被引用次数（如果被引用次数>=1说明服务器存在该文件，执行秒传）（如果是上传了但是上传了一半则断点续传，将上次文件传输到的位置放入上传文件回复包中）（若是没上传过，则通过文件名创建一个文件存储地址，将文件信息加入到数据库文件信息列表当中）——》客户端收到文件上传信息回复包后，根据类型进行处理，根据回复包找到文件MD5值，根据MD5值找到对应文件信息。

——》如果是断点续传和正常传递，则把文件指针移动到文件上传回复包中文件位置对应的地方（正常传是0），开始循环读取文件并发送文件信息包。

注意点：不能在UI线程上直接传输，较大的文件会阻塞UI线程。可以采用多线程或者线程池的方式来上传文件

#### 客户端下载

