# MySQL

## 名词

属性: 特征

表中某一列: 字段

元组: 表的一行叫一个元组

码： 表中唯一确定一个元组的属性，码不止一个, 叫这些为候选码

主码：从候选码挑选一个主要确定这一行的属性

主属性：只要在任何一个候选码中出现过，这个属性叫主属性

非主属性: 没有在任何一个候选码中出现过。

## 数据定义语言(DDL)&数据控制语言(DCL)

1. 创建数据库
	- create schemas
	- create database

2. 设置用户权限

	```mysql
	
	management > users and priviledges
	localhost 127.0.0.1 % 本机任意网卡
	创建用户
	# 临时授权
	grant select on 表名 to user;
	# 取消授权
	revoke select on 表名 from user:
	```

3. 创建&删除数据表

	- 选定数据库

		```mysql
		use 数据库名;
		```

	- 创建表

		```mysql
		create table 表名(列名 类型 约束, 列名 类型 约束, 列名 类型 约束···);
		```

	- 建表约束

		```mysql
		1.主键约束	primary key	   值唯一的列,不允许重复,不允许为空主键列是唯一列，其他列不可以是主键
		2.唯一	 unique			可以有多列唯一，值不重复，但可以为空
		3.默认值	default
		4.非空	 not null
		5.自增	 auto increment
		6.外键约束  foreign key
		7.check校验(mysql不支持)
		```

	- 删除表

		```mysql
		drop table 表名;
		```

	- 修改表

		```mysql
		alter table 表名 add column 列名 类型;	# 增加一列
		alter table 表名 modify 列名 属性;		# 修改列属性
		alter table 表名 drop column 列名;		 # 删除列
		```

	- 拷贝表

		```mysql
		create table 表1 like 表2;				# 拷贝表结构, 但是没有数据
		create table 表1 as (select * from 表2);	# 拷贝数据, 但是不会有主键和索引
		create table 表1 like 表2; insert into 表1 select * from 表2;	# 又要有表结构, 又要有数据
		```

## 范式

### 第一范式(1NF)

> 属性不可分

### 第二范式(2NF)

> 在1NF基础上, 不存在组合关键字中的某些字段决定非关键字段

(组合关键字不可拆)

例子: 选课课表SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)

组合关键字(学号, 课程名称) --> (姓名，年龄，成绩，学分)

但存在组合关键字的部分关键字决定非关键字字段：

- (学号) --> （姓名, 年龄)
- (课程名称) --> (学分)

问题：

1. 数据冗余
2. 更新异常
3. 插入异常

### 第三范式(3NF)

> 在2NF基础上,  不存在传递依赖

例子：学生关系表(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)

(学号) --> 

### BCNF(鲍依斯-科得范式)

> 在前三个范式的基础上, 不存在关键字段决定关键字段

![image-20230805182747390](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230805182747390.png)

## 数据操作语言(DML) -- CRUD

### 数据查询

#### 高级查询

##### 条件查询

1. 相等 

	```mysql
	where 列名 = 值
	```

2. 不相等

	```mysql
	where 列名 != 值 (只有MySQL支持) 或者 where 列名 <> 值
	```

3. 或者 

	```mysql
	or 连接两个条件
	```

4. 并且

	```mysql
	and 连接两个条件
	```

5. 介于之间

	```mysql
	between and
	```

	



##### 模糊查询

##### 查询不重复记录

##### 排序和限制(分页查询)

##### 聚合

##### 表连接(多表查询)

###### 内连接

内联

```mysql
表1 + inner join + 表2 + on + 连接条件
```



###### 外连接

##### 子查询

##### 记录联合

### 插入数据

### 修改数据

### 删除数据

## 视图

> 视图是一个表或多个表导出的虚表，不是真实存在的

### 语法

1. 创建视图

	```mysql
	CREATE view 视图名 as （SELECT 语句）
	```

2. 删除视图

	```mysql
	drop view 视图名
	```

### 优缺点

- 优点: sql语句在网络传输中，使用视图可以减少流量，保证sql语句不会有问题，更安全
- 缺点: 执行效率并不会提高，还是执行原来的语句

## 函数&存储过程

### 函数

#### 语法

1. 创建函数

	```mysql
	delimiter // # 定义结束标志
	create function 函数名(参数1 类型, 参数2 类型...)
	returns 返回值类型
	begin 
		declare 变量名 类型 default 值; # 声明局部变量并赋初值
		set 变量 = 值; # 赋值操作
		return 值;
	end //
	delimiter;
	```

2. 删除函数

	```mysql
	drop function 函数名;
	drop function if exists 函数名;
	```

3. 变量

	- 局部变量

	- 会话变量: 本次连接会话有效, 不需要定义声明, 直接使用

		```mysql
		@变量名
		```

	- 系统变量(全局变量): root 才能使用，一直都有效

		```mysql
		@@变量名
		```

4. 选择语句

	```mysql
	if (a > b) then 执行语句;
	elseif (a = b) then 执行语句; # 判断相等用"="
	else 执行语句;
	end if;
	```

5. 选择语句

	```mysql
	case 变量 when 值 then ...;
			 when 值 then ...;
			 when 值 then ...;
			 else 执行语句;
	end case;
	
	```

6. 循环语句

	```mysql
	while 条件
	do 
		执行语句;
	end while;
	```

### 存储过程

> 存储过程(Stored Procedure) 是在大型数据库系统中， 一组为了完成特定功能的SQL语句集, 它存储在数据库中, 一次编译永久有效, 用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数) 来执行它。
>
> 存储过程是数据库中的一个重要对象， 在数据量特别庞大的情况下利用存储过程能达到倍速的效率提升.

#### 优点

1. 减少网络流量 存储过程直接在服务器端运行，减少了与客户机的交互
2. 增强了代码的重用性和共享性
3. 加快系统运行速度
4. 使用灵活
5. 作为一种安全机制来充分利用

#### 语法

1. 定义存储过程

	```mysql
	delimiter //
	create procedure 过程名(参数1 类型, 参数2 类型...)
	begin 
		执行语句1;
		执行语句2;
	end //
	delimiter;
	```
	
2. 执行存储过程
	
```mysql
	
```

### 存储过程和函数的区别

1) 返回值: 函数必须返回一个值，而存储过程可以不返回值或者返回多个结果集。

2) 调用方式:函数可以像其他表达式一样被调用，可以作为 SELECT 语的一部分使用而存储过程则需要通过 CALL 语来调用执行

3) 数据处理: 存储过程可以包含数据定义语句 (如 CREATE、ALTER、DROP)，以及事务控制语句。(如 COMMIT、ROLLBACK)函数否能包含这些语句。

4) 执行权限:存储过程需要执行时具有执行权限的用户或角色，而函数可以由任何具有访问权限的用户或角色使用

5) 灵活性:存储过程通常用于执行复杂的操作，可以包含条件判断、循环等控制结构，因此更加灵活。而函数主要用于计算和返回单个结果，适合用于简单的数学计算、字符串处理等场景。

## 触发器

> 是一种特殊的存储过程, 当指定事件发生时，系统自动调用

触发条件:

- 修改表数据
- 插入表数据
- 删除表数据

### 语法

1. 创建触发器

	```mysql
	delimiter //
	create trigger 触发器名
	after/before 操作 # 在发生某某操作之后/之前
	on 表名 # 产生触发的表
	for each row # 影响每一行
	begin 
		执行操作;
	end;
	delimiter;
	```

2. 删除触发器

	```mysql
	drop 
	```

## 索引篇

> 形象的表达, 索引是数据的目录

### 语法

1. 创建索引

	```mysql
	# 建表时
	index(列名)
	# 单独创建索引
	create index 索引名 on 表名(列名);
	```

2. 删除索引

	```mysql
	drop index 索引名 on 表名;
	```


### 索引的分类

#### 按数据结构分类

1. B+树索引
2. Hash索引
3. Full-text索引

##### B+树索引

> B+树：
>
> 多叉树， 叶子结点存放数据，非叶子结点存放索引 (叶子结点之间用双向链表连接)
>
> 1. 搜索时间复杂度**O(log~d~N)**
>
> 	d是每个节点最多拥有的子节点个数，N为每个非叶子节点大小最好是**页大小**,因为磁盘IO读取一次数据是读取一页：
>
> 	- **如果节点大小小于页大小，**就意味着B+树的分叉少，深度就会变大，意味着访问时访问的节点数量变多，IO次数会变大。
>
> 	- **如果节点大小大于页大小，**就意味着搜索过程中为了获取一个完整节点来查找数据，需要多次的IO来获取这个节点，这显然会很消耗时间。
> 	
> 	在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。
>
> 2. 基于范围顺序查找
>
> 	B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。Hash 表虽然更快O(1)但不适合做范围查询，它更适合做等值的查询，且hash表占空间大
>
> 	

![image-20230805201006345](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230805201006345.png)

![image-20230805201324813](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230805201324813.png)

![image-20230805201611094](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230805201611094.png)

![image-20230805201927567](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230805201927567.png)

![image-20230805202304815](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230805202304815.png)

![image-20230806182725787](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230806182725787.png)

![image-20230806183247648](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230806183247648.png)

![image-20230806184156009](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230806184156009.png)

![image-20230806184438856](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230806184438856.png)

![image-20230806185300556](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230806185300556.png)

![image-20230806185940307](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230806185940307.png)





##### Hash索引



##### Full-text索引

#### 按物理存储分类

##### 聚簇索引(主键索引)

主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；

##### 二级索引(辅助索引)

B+树的叶子节点的value值存的是主键，如果查询的的数据在二级索引里面查询不到，需要**回表**(根据主键查询主键索引)，

#### 按字段特性分类

##### 主键索引

##### 唯一索引

##### 普通索引

##### 前缀索引

#### 按字段个数分类

##### 单例索引

##### 联合索引(复合索引) --- 建立在多列上的索引

- **最左匹配原则**，对于联合索引，最左字段是有序的，而后序字段是全局无序，局部相对有序的。（如果不遵循最左匹配原则进行查询，索引就会失效）

- **联合索引范围查询**, 联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配

-  **索引下推**,可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

- **索引区分度**, 建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。
	$$
	区分度 = {distinct(column)\over count(*)}
	$$

- **联合索引进行排序**. 利用索引的有序性, 避免在文件排序，提高查询效率

### 索引的使用场景

> 使用索引是为了提高查询效率, 如果不使用索引，执行查询时要**全表逐个查询**

#### 缺点（索引不是万能钥匙）

1. 占用物理空间，数量越大，占用空间越大，会影响表的最大存储量

2. 创建索引和维护索引要耗费时间

3. 降低表的增删改效率，需要维护B+树的有序性，每次操作都需要动态维护

#### 不需要创建索引的场景

1. 表数据太少，不需要创建索引

2. 经常更新的字段不需要创建索引，避免维护B+树的有序性降低数据库的性能

3. 字段存在大量重复数据，比如性别不需要创建索引
4. WHERE条件，GROUP BY，ORDER BY 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。

### 优化索引的方法

#### 前缀索引优化



#### 覆盖索引优化

#### 主键索引最好是自增的

因为每次**插入一条新记录，都是追加操作，不需要重新移动数据**，因此这种插入数据的方法效率非常高。

**如果我们使用非自增主键**，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为**页分裂**。**页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率**。

因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。

主键字段的长度不要太大，因为**主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小**。

#### 防止索引失效

### InnoDB是如何存储数据的?

InnoDB是按**数据页**存储并读写数据的，数据页之间通过**双向链表**连接，虽然数据库中的每个记录都是一个行记录，但是读取按行读取的话，需要很多次IO操作，效率会很低. InnoDB的默认数据页大小是**16KB**

数据页包括七个部分：

<img src="https://raw.githubusercontent.com/Cris-Cui/ImagesForBlog/master/Blog/20230909093659.png" style="zoom:50%;" />

<img src="https://cdn.xiaolincoding.com//mysql/other/fabd6dadd61a0aa342d7107213955a72.png" alt="图片" style="zoom:50%;" />

**数据页中的记录按照「主键」顺序组成单向链表**，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。

因此，数据页中有一个**页目录**，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。

### B+树如何进行查询的？

因为B+树是一个【矮胖】的多叉树型结构，每一个节点都是一个数据页，非叶子节点只存放目录项作为索引，分层目录项来降低每一层的搜索量。

搜索过程：

1. 从根节点开始，通过二分快速定位到符合页内范围包含查询值的页，然后通过指针去查看下一层的数据页
2. 还是通过二分在非叶子节点继续定位符合页内范围包含查询值的页，如此继续往下处理。
3. 到达叶子节点，通过二分快速定位查询记录在页目录指向的哪一个数据分组中，定位到后遍历该数据分组，得到想要的记录。

### 为什么InnoDB采用B+树?

​	要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/0 的操作次数内完成。

二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。

为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。

而树的高度决定于磁盘 I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。

B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。

但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

- B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
- B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
- B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。



### 如何知道索引是否触发?

> 使用关键字explain 

```mysql
explain select * from t_user where id;
```

显示10列信息:

- id 选择标识符
- select_type 表示查询的类型
- table 输出结果集的表
- type 表示表的连接类型
- possible_kyes 表示查询时，可能使用的索引
- **key** 表示实际使用的索引
- **key_len** 索引字段的长度
- ref 列与索引的比较
- **rows** 扫描出的行数(估算的行数)
- extra 执行情况的描述和说明

## 事务篇

> 数据库事务是作为单个逻辑工作单元执行的一系列sql操作， 要求**要么都执行,要么都不执行**

### 事务四大特性ACID

- A Atom 原子性，事务是最小工作单元,不可再分,要么都执行,要么都不执行（事务在执行过程中发生错误，会被回滚到事务开始前的状态）
- C consistency 一致性,指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。
- l  isolusion 隔离性 并发执行的事务是隔离的，保证多个事务互不影响
- D durability 持久性 持久保存到本地 事务-->提交 数据发生改变是永久的

**持久性**是通过 redo log （重做日志）来保证的；

**原子性**是通过 undo log（回滚日志） 来保证的；

**隔离性**是通过 MVCC（多版本并发控制） 或锁机制来保证的；

**一致性**则是通过持久性+原子性+隔离性来保证；

### 语法

```mysql
start transaction;	# 开启事务
执行语句1;
执行语句2;
...
commit; 	# 提交
rollback;	# 回滚
```

### 事务日志- 重做日志和回滚日志

- 重做日志。采用的方式是预写日志方式。也就是写数据之前先写日志。存储的是执行语句。

	(重写日志缓存 和 重写日志文件 )当开始一个事务的时候。会记录该事务日志序列号当事务执行时，先往InnoDB引擎日志缓存里插入事务日志(执行语句)当事务提交时，必须先将写入磁盘

- 回滚日志 存储都是执行语句存储引擎的日志缓存，存储与重做日志相反的语句比如 重做日志里面是 insert --> delete update --> 相反的update

数据库的持久性除了文件缓存到本地之外。 有一套机制可以恢复数据库mysql InnoDB引擎 通过回滚日志,将所有已经完成 或存储在磁盘没完成的事务进行回滚然后redo 重做日志里面的全部重新执行一遍,恢复数据

### 并发事务引发的错误类型

#### 脏读

> 读到其他事务未提交的数据；

#### 不可重复读

> 前后读取的数据不一致；

#### 幻读

> 前后读取的记录数量不一致。

### 四种隔离级别

>  数据库并发事务采用隔离等级，隔离级别越高，性能效率就越低

1.**读未提交**-- read uncommited 指一个事务还没提交时，它做的变更就能被其他事务看到；
在读数据时不会检查或使用任何锁。在隔离等级中,会发生脏读 相当于没有并发控制

2.**读已提交 ** read  commit 指一个事务提交之后，它做的变更才能被其他事务看到；
(大多数的数据库默认的隔离等级 SQLServer Oracle只读取提交的数据并等待其他事务释放排他锁,读数据的共享锁在读操作之后会立即释可能出现的问题->不可重复读 可以解决脏读

3.**可重复读** repeatable read (rr) 指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的
**MySQL InnoDB 引擎的默认隔离级别**；只读取提交的数据，并等待其它事务释放排它锁, 读取数据的共享锁在事务结束时释放(共享锁是行锁)

4.**串行化**  会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；
可以用来解决幻读问题 强制事务排列执行 不可能发生冲突 解决幻读实质是锁定受影响的数据范围，阻止新数据插入查询所涉及的范围

<img src="https://cdn.xiaolincoding.com//mysql/other/4e98ea2e60923b969790898565b4d643.png" alt="图片" style="zoom:50%;" />



#### mysql 默认的隔离等级

mysql 默认的隔离等级是可重复读,通过多版本并发控制MVCC

对于快照读InnoDB使用MVCC 解决幻读

对于当前读,InnoDB 通过间隙锁(锁一个范围)解决幻读

杂记:
1.MyISAM InnoDB 区别 行锁关于 InnoDB 使用的行锁:
用索引去查数据的时候才会用行锁 锁定 key，其他默认的情况使用 表锁

2.页面锁，是特定的引擎使用的，锁定多行
3.排他锁是在事务提交之后释放

#### MVCC 多版本并发控制

对应的 基于锁的并发控制 Lock-based concurrent control LBCC
MVCC 最大优势:读不加锁，认为读写不冲突，在读多写少的情况下,读写不冲突十分重要

可以极大的增强系统的并发能力

思路 MVCC 是一个乐观锁，处理并发的时候,比较乐观的看待并发问题

认为一般情况没有数据冲突,只有在数据修改的时候才会出现冲突,只需要判断先后有没有修改如果没有修改，不需要管理,如果有修改,就认为有并发的冲突,此次读写失败，尝试下一次读写乐观锁---种实现的方式 CAS机制 ( compare and swap )比较然后交换，就是空间没有改写，可以操作，被其他的线程改写过，此次操作失败进入下一次操作,再继续判断 -- 无锁编程

CAS机制包含三个操作数:1)内存位置V 2) 预期原值A 3) 新值B 如果内存位置上的值与预期原值相等，则将该位置的值更新为新值.CAS操作是原子性的，因此在多线程环境下使用能保证线程安全， 如果多个线程执行CAS操作，只有其中一个线程能够成功执行，其他线程需要重新执行操作。 如果内存位置上的值与预期原值不相等，说明共享数据已经被修改，放弃所做的操作，然后重新执行刚才的操作，直到重试成功。

> 在学习MVCC之前，必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?当前读像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读? 就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁快照读 -致性非锁定读取，使用普通select 语读取读取快照版本,通过MVCC的ReadView实现(快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读，之所以出现快照读的情况，是基于提高并发性能的考虑，在很多情况下，避免了加锁操作，降低了开销;
> 快照读可能读到的并不一定是数据的最新版本，可能是之前的历史版本



##### MVCC 怎么实现?

实现MVCC依靠隐藏列，undo log 以及 Read View来实现隐藏列
DB TRX ID 记录插入或更新该行，最后一个事务的事务ID,每执行一个事务,+1DB ROLLPTR 指向修改该行对应的回滚日志的指针
DBROWID 单调递增的行IDundo log 改动的数据都保存在undo log 中,同时里面有保存事务的id，可以用于生成快照读，同样回滚可以实现数据恢复
Read View SQL语句执行前都可以得到一个ReadView,它是一个副本,主要用来知道哪些事务可以看到数据，哪些不可以

## 锁篇

> 保证并发访问的一致性和有效性

Mysql 涉及的三种锁

### 全局锁

- `flush tables with read lock`执行后， 整个数据库就处于**只读状态**了

- 对数据的增删改操作，对表结构的修改操作都会被阻塞。
- `unlock tables`释放全局锁(会话断开了，全局锁会被自动释放)

应用场景：

1. **全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。
    但是如果数据库内数据很多，备份需要花费很多时间，且备份期间只能读数据，导致业务停滞。可以使用**可重复读的隔离级别**
在备份数据库之前先开启事务，先创建Read View，然后整个事务的执行期间使用这个ReadView，由于MVCC的支持，备份期间业务依然可以对数据进行更新操作。**注：**备份数据库的工具`mysqldump`, 使用时加上`-single-transaction`参数。

### 表级锁

> MySQL 里面表级别的锁有这几种：

#### 表锁

```mysql
//表级别的共享锁，也就是读锁；
lock tables t_student read;

//表级别的独占锁，也就是写锁；
lock tables t_stuent write;

// 释放当前会话的所有表锁(会话退出后，也会释放所有表锁)
unlock tables
```

表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。

**尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，**InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。

开销小 加锁快,   不会死锁 锁冲突概率较高

#### 元数据锁（MDL）

#### 意向锁

#### AUTO-INC 锁



1.表级锁: 锁表, 开销小 加锁快,   不会死锁，锁定粒度大 并发效率低 锁冲突概率较高

2.行级锁: 锁行, 开销大,加锁慢，可能死锁，锁粒度小     并发效率高,锁冲突概率较小

3.页面锁: 粒度介于表锁和行锁,并发一般,开销和速度也是介于表和行的



### 不同引擎关于锁的模式

**MyISAM** -- 只有表锁
有两种模式:表共享锁( table Read Lock ) 表独占写锁(Table write lock)
读锁锁定，不会影响其他读的，但是会影响写写锁，是又影响其他写，又影响其他读.
共享锁 -- 读
排他锁 --写

MyISAM-- 不支持 事务的 显式的锁定表 LOCK - UNCLOCK

```mysql
LOCK tables orders read local, order detail read local; //显式表锁
select SUM(total) from orders;
select SUM(subtotal) from order detail;
UNCLOCK tables;
```

两个表,如果想同一个时刻查询查看是否相等,可以显式使用表锁
MyISAM 锁的调度
读和写是互斥的，假如一个进程请求MyISAM表的读锁，另一个进程请求同一个MyISAM表的写锁，MYSQL是怎么处理的?

**写优先.**即使在所等待队列里边读的进程排在前面。写的进程排在后边。也会先去执行写锁

**InnoDB** 锁问题
nnoDB和MyISAM最大的不同 1.支持事务 2.采用行锁

事务
sql1;
sql2;
只能一个一个执行.可能需要关联，sql2执行在sql1执行成功的前提下,去执行sql1 没有正常执行,sgl2 就不执行了你要怎么做?图书管理 sql1 插入书籍 sql2 cout +1可以使用事务 -- 要么都执行，要么都不执行。理解，可以近似看成线程

### 



## 面试常见问题

> Q: mysql 一张表可以有多少行数据?
>
> A: 极限情况是 **500万条**

![image-20230804204837287](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230804204837287.png)

> Q: 一条SQL语句在数据库中的执行流程?
>
> A: ![image-20230805185519086](C:%5CUsers%5C28568%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230805185519086.png)

> Q: SQL语句中每种关键字的先后执行顺序?
>
> A: 
>
> 1. from子句组装来自不同数据源的数据(笛卡尔积计算)
> 2. 应用on筛选器
> 3. 执行join
> 4. where子句基于指定条件对记录行进行筛选
> 5. group by子句将数据划分为多个分组
> 6. 聚集函数进行计算
> 7. 使用having子句筛选分组(二次筛选)
> 8. select的字段
> 9. distinct去除重复行
> 10. order by 对结果集进行排序
> 11. limit 查询指定范围

> Q:
>
> A: 